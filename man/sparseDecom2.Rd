% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/sparseDecom2.R
\name{sparseDecom2}
\alias{sparseDecom2}
\title{Convenience wrapper for 2-view eigenanatomy decomposition.}
\usage{
sparseDecom2(inmatrix, inmask = c(NA, NA), sparseness = c(0.01, 0.01),
  nvecs = 3, its = 2, cthresh = c(0, 0), statdir = NA, perms = 0,
  uselong = 0, z = 0, smooth = 0, robust = 0, mycoption = 0,
  initializationList = list(), initializationList2 = list(), ell1 = 0.05,
  priorWeight = 0)
}
\arguments{
\item{inmatrix}{input as inmatrix=list(mat1,mat2). n by p input matrix and n
by q input matrix , spatial variable lies along columns.}

\item{inmask}{optional pair of antsImage masks}

\item{sparseness}{a c(.,.) pair of values e.g c(0.01,0.1) enforces an
unsigned 99 percent and 90 percent sparse solution for each respective view}

\item{nvecs}{number of eigenvector pairs}

\item{its}{number of iterations, 10 or 20 usually sufficient}

\item{cthresh}{cluster threshold pair}

\item{statdir}{temporary directory if you want to look at full output}

\item{perms}{number of permutations}

\item{uselong}{enforce solutions of both views to be the same - requires
matrices to be the same size}

\item{z}{subject space (low-dimensional space) sparseness value}

\item{smooth}{smooth the data (only available when mask is used)}

\item{robust}{rank transform input matrices}

\item{mycoption}{enforce 1 - spatial orthogonality, 2 - low-dimensional
orthogonality or 0 - both}

\item{initializationList}{initialization for first view}

\item{initializationList2}{initialization for 2nd view}

\item{ell1}{gradient descent parameter, if negative then l0 otherwise use l1}

\item{priorWeight}{Scalar value weight on prior between 0 (prior is weak)
and 1 (prior is strong).  Only engaged if initialization is used}
}
\value{
outputs a decomposition of a pair of matrices
}
\description{
Decomposes two matrices into paired sparse eigenevectors to maximize
canonical correlation.
}
\examples{
mat<-replicate(100, rnorm(20))
mat2<-replicate(100, rnorm(20))
mydecom<-sparseDecom2( inmatrix=list(mat,mat2),
  sparseness=c(0.1,0.3) , nvecs=3, its=3, perms=0)
wt<-0.666
mat3<-mat*wt+mat2*(1-wt)
mydecom<-sparseDecom2( inmatrix=list(mat,mat3),
  sparseness=c(0.2,0.2), nvecs=5, its=10, perms=5 )

\dontrun{
# a masked example
im<-antsImageRead( getANTsRData("r64"))
dd<- im > 250
mask<-antsImageClone( im )
mask[ !dd ]<-0
mask[ dd ]<-1
mat1<-matrix( rnorm(sum(dd)*10) , nrow=10 )
mat2<-matrix( rnorm(sum(dd)*10) , nrow=10 )
initlist<-list()
for ( nvecs in 1:2 ) {
  init1<-antsImageClone( mask )
  init1[dd]<-rnorm(sum(dd))
  initlist<-lappend( initlist, init1 )
}
ff<-sparseDecom2( inmatrix=list(mat1,mat2), inmask=list(mask,mask),
  sparseness=c(0.1,0.1) ,nvecs=length(initlist) , smooth=1,
  cthresh=c(0,0), initializationList = initlist ,ell1 = 11 )
### now SNPs ###
rf<-usePkg('randomForest')
bg<-usePkg('BGLR')
if ( bg & rf ) {
data(mice)
snps<-mice.X
numericalpheno<-as.matrix( mice.pheno[,c(4,5,13,15) ] )
numericalpheno<-residuals( lm( numericalpheno ~
  as.factor(mice.pheno$Litter) ) )
nfolds<-6
train<-sample( rep( c(1:nfolds), 1800/nfolds ) )
train<-( train < 4 )
snpd<-sparseDecom2( inmatrix=list( ( as.matrix(snps[train,]) ),
  numericalpheno[train,] ), nvecs=20, sparseness=c( 0.001, -0.5 ),
  its=3, ell1=0.1 , z=-1 )
for ( j in 3:3) {
traindf<-data.frame( bmi=numericalpheno[ train,j] ,
   snpse=as.matrix( snps[train, ] ) \%*\% as.matrix( snpd$eig1 ) )
testdf <-data.frame( bmi=numericalpheno[!train,j] ,
   snpse=as.matrix( snps[!train,] ) \%*\% as.matrix( snpd$eig1 ) )
myrf<-randomForest( bmi ~ . , data=traindf )
preddf<-predict(myrf, newdata=testdf )
print( cor.test(preddf, testdf$bmi ) )
plot( preddf, testdf$bmi )
}
} # check bg and rf
}
}
\author{
Avants BB
}

