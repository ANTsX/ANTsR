% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiscaleSVDxpts.R
\name{smoothRegression}
\alias{smoothRegression}
\title{smooth matrix-based regression}
\usage{
smoothRegression(x, y, iterations = 10, gamma = 1e-06,
  sparsenessQuantile = 0.5, positivity = FALSE, smoothingMatrix = NA,
  nv = 1, verbose = FALSE)
}
\arguments{
\item{x}{input matrix on which prediction is based}

\item{y}{target vector}

\item{iterations}{number of gradient descent iterations}

\item{gamma}{step size for gradient descent}

\item{sparsenessQuantile}{quantile to control sparseness - higher is sparser.}

\item{positivity}{restrict to positive or negative solution (beta) weights.
the sign restriction is determined by \code{sparsenessQuantile} being greater
or lesser than 0.5.}

\item{smoothingMatrix}{allows parameter smoothing, should be square and same
size as input matrix}

\item{nv}{number of predictor spatial vectors}

\item{verbose}{boolean option}
}
\value{
vector of size p is output
}
\description{
Reconstruct a n by 1 vector given n by p matrix of predictors.
}
\examples{

\dontrun{
mask = getMask( antsImageRead( getANTsRData( 'r16' ) ) )
spatmat = t( imageDomainToSpatialMatrix( mask, mask ) )
smoomat = knnSmoothingMatrix( spatmat, k = 200, sigma = 1.0 )
mat <- matrix(rnorm(sum(mask)*50),ncol=sum(mask),nrow=50)
mat[ 1:25,100:10000]=mat[ 1:25,100:10000]+1
age = rnorm( 1:nrow(mat))
for ( i in c( 5000:6000, 10000:11000, 16000:17000 )  ){
  mat[ , i ] = age*0.1 + mat[,i]
  }
sel = 1:25
fit = smoothRegression( x=mat[sel,], y=age[sel], iterations = 10,
  gamma = 1.e-6, sparsenessQuantile = 0.5,
  smoothingMatrix = smoomat, verbose=T )
tt = mat \%*\% fit$v
print( cor.test( age[-sel], tt[-sel,1] ) )
vimg = makeImage( mask, (fit$v[,1] ) ); print(range(vimg)*10)
plot( mask, vimg, window.overlay=range(abs(vimg)))
}
}
\author{
Avants BB
}
