% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiscaleSVDxpts.R
\name{nns_flow}
\alias{nns_flow}
\title{Riemannian-Proximal Flow for Nonnegative Orthogonal Matrices}
\usage{
nns_flow(
  Y0,
  X0 = NULL,
  w = 0.5,
  lambda = 1 - w,
  retraction = c("soft", "polar", "qr"),
  max_iter = 1000,
  tol = 1e-04,
  verbose = FALSE,
  seed = NULL,
  apply_nonneg = TRUE,
  opt_type = "adam",
  record_every = 1,
  window_size = 5
)
}
\arguments{
\item{Y0}{Numeric matrix (p x k). Initial iterate.}

\item{X0}{Optional numeric matrix (p x k). Target matrix for fidelity term.}

\item{w}{Numeric in [0,1]. Weight for fidelity term; 1-w weights orthogonality term.}

\item{lambda}{Numeric in [0,1]. Lambda for soft retraction mixing (used only if retraction = "soft"). Defaults to 1-w.}

\item{retraction}{Retraction method: one of "soft", "polar", "qr".}

\item{max_iter}{Integer. Maximum number of iterations.}

\item{tol}{Numeric. Convergence tolerance for relative energy reduction over the window.}

\item{verbose}{Logical. Whether to print iteration diagnostics.}

\item{seed}{Optional integer. Random seed for reproducibility.}

\item{apply_nonneg}{Logical. If TRUE, apply nonnegativity projection at each iteration.}

\item{opt_type}{Type of optimizer to use: 'lookahead' (default) or 'adam'.}

\item{record_every}{Integer. How often to record diagnostics into the trace log.}

\item{window_size}{Integer. Size of the moving window for checking energy reduction convergence.}
}
\value{
A list containing:
  \item{Y}{Final matrix iterate.}
  \item{traces}{Data frame of iteration diagnostics (iteration, time, energy, orthogonality residual, nonnegativity violation, lambda).}
  \item{final_iter}{Number of iterations completed.}
}
\description{
Optimizes a matrix under simultaneous orthogonality and nonnegativity constraints
using a combination of Riemannian optimization on the Stiefel manifold and proximal projections.
}
\details{
Optimizes the objective \eqn{F(Y) = w \cdot (1/2) ||Y - X_0||_F^2 + (1-w) \cdot (1/4) ||(Y^T Y / ||Y||_F^2) - \mathrm{diag}(...)||_F^2},
where the first term encourages fidelity to \eqn{X_0} and the second enforces orthogonality up to scale.
Convergence is determined by relative energy reduction over a moving window of size \code{window_size}:
if \eqn{(E_{t-window_size} - E_t) / |E_{t-window_size}| < tol}, the algorithm stops.
The algorithm uses Riemannian optimization on the Stiefel manifold with polar, QR, or soft retractions,
followed by a proximal nonnegativity projection \eqn{P_+(Y) = \max(Y, 0)}.
The learning rate follows a cosine annealing schedule from 1.0 to 1e-6.
}
\examples{
set.seed(1)
Y0 <- matrix(runif(9), 3, 3)
X0 <- Y0
out <- nns_flow(Y0, X0, w = 0.99, max_iter = 20)
all.equal(out$Y, X0, tolerance = 1e-3)

}
