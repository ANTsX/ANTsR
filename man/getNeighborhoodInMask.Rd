% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/getNeighborhood.R
\name{getNeighborhoodInMask}
\alias{getNeighborhoodInMask}
\title{Get neighborhoods for voxels within mask}
\usage{
getNeighborhoodInMask(
  image,
  mask,
  radius,
  physical.coordinates = FALSE,
  boundary.condition = "NA",
  spatial.info = FALSE,
  get.gradient = FALSE
)
}
\arguments{
\item{image}{image object of S4 class \code{antsImage} to get values from.}

\item{mask}{image object of S4 class \code{antsImage} indicating which voxels to
examine. Each voxel > 0 will be used as the center of a neighborhood}

\item{radius}{array of values for neighborhood radius (in voxels)}

\item{physical.coordinates}{logical indicating if voxel indices and
offsets should be in voxel or physical coordinates}

\item{boundary.condition}{string indicating how to handle voxels in a
neighborhood, but not in the mask. See \code{Details}.}

\item{spatial.info}{a boolean indicating of voxel locations and neighborhood
offsets should be returned along with pixel values.}

\item{get.gradient}{a boolean indicating if a matrix of gradients (at the
center voxel) should be returned in addition to the value matrix (WIP)}
}
\value{
if \code{spatial.info} is false: a matrix of pixel values where the number of rows
is the size of the neighborhood and there is a column for each voxel

if \code{spatial.info} is true, a list containing three matrices:
\itemize{
 \item{values: }{matrix of pixel values where the number of rows
 is the size of the neighborhood and there is a column for each voxel.}
 \item{indices: }{matrix providing the center coordinates for each neighborhood}
 \item{offsets: }{matrix providing the offsets from center for each
  voxel in a neighborhood}
}
}
\description{
this converts a scalar image to a matrix with rows that contain neighbors
around a center voxel
}
\details{
\code{boundary.condition} should be one of:
\itemize{
  \item{\code{NA}: }{Fill values with \code{NA}.}
  \item{\code{image}: }{Use image value, even if not in mask.}
  \item{\code{mean}: }{Use man of all non-\code{NA} values for that neighborhood.}
}
}
\examples{
r16 <- getANTsRData("r16")
r16 <- antsImageRead(r16, 2)
mask <- getMask(r16, lowThresh = mean(r16), cleanup = 1)
radius <- rep(2, 2)
mat <- getNeighborhoodInMask(r16, mask, radius)
mat <- getNeighborhoodInMask(r16, mask, radius,
  boundary.condition = "image"
)
mat <- getNeighborhoodInMask(r16, mask, radius,
  boundary.condition = "mean"
)
randlist <- getNeighborhoodInMask(r16, mask, radius,
  physical.coordinates = TRUE
)
arr <- as.array(r16)
testthat::expect_error(getNeighborhoodInMask(arr, mask, radius), "antsImage")
testthat::expect_error(
  getNeighborhoodInMask(r16, as.numeric(mask), radius),
  "mask must be"
)
testthat::expect_error(
  getNeighborhoodInMask(r16, mask, as.character(radius)),
  "radius must be"
)
# testthat::expect_error(getNeighborhoodInMask(r16,mask,c(radius, 3)),
# "Radius must")

}
\author{
Duda JT
}
