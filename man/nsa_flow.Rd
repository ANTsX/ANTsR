% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiscaleSVDxpts.R
\name{nsa_flow}
\alias{nsa_flow}
\title{NSA-Flow Optimization}
\usage{
nsa_flow(
  Y0,
  X0 = NULL,
  w = 0.5,
  retraction = c("polar", "soft_polar", "none"),
  max_iter = 500,
  tol = 1e-05,
  verbose = FALSE,
  seed = 42,
  apply_nonneg = TRUE,
  optimizer = "armijo_gradient",
  initial_learning_rate = 0.001,
  record_every = 1,
  window_size = 5,
  c1_armijo = 1e-06,
  plot = FALSE
)
}
\arguments{
\item{Y0}{Numeric matrix of size \code{p x k}, the initial guess for the solution.}

\item{X0}{Numeric matrix of size \code{p x k}, the target matrix for fidelity.
If \code{NULL}, initialized as \code{pmax(Y0, 0)} with a small perturbation added to \code{Y0}.}

\item{w}{Numeric scalar in \code{[0,1]}, weighting the trade-off between fidelity
(1 - w) and orthogonality (w). Default is 0.5.}

\item{retraction}{Character string specifying the retraction method to enforce
orthogonality constraints.}

\item{max_iter}{Integer, maximum number of iterations. Default is 100.}

\item{tol}{Numeric, tolerance for convergence based on relative gradient norm
and energy stability. Default is 1e-6.}

\item{verbose}{Logical, if \code{TRUE}, prints iteration details. Default is \code{FALSE}.}

\item{seed}{Integer, random seed for reproducibility. If \code{NULL}, no seed is set.
Default is 42.}

\item{apply_nonneg}{Logical, if \code{TRUE}, enforces non-negativity on the solution
after retraction. Default is \code{TRUE}.}

\item{optimizer}{Character string, optimization algorithm to use.
Currently only \code{"adam"} is supported. Default is \code{"adam"}.}

\item{initial_learning_rate}{Numeric, initial learning rate for the optimizer.
Default is 1e-3.}

\item{record_every}{Integer, frequency of recording iteration metrics.
Default is 1 (record every iteration).}

\item{window_size}{Integer, size of the window for energy stability convergence check.
Default is 5.}

\item{c1_armijo}{Numeric, Armijo condition constant for line search.}

\item{plot}{Logical, if \code{TRUE}, generates a ggplot of fidelity and orthogonality
traces with dual axes. Default is \code{FALSE}.}
}
\value{
A list containing:
  \itemize{
    \item \code{Y}: Numeric matrix, the best solution found (lowest total energy).
    \item \code{traces}: Data frame with columns \code{iter}, \code{time},
          \code{fidelity}, \code{orthogonality}, and \code{total_energy}
          for recorded iterations.
    \item \code{final_iter}: Integer, number of iterations performed.
    \item \code{plot}: ggplot object of the optimization trace
          (if \code{plot = TRUE}), otherwise \code{NULL}.
    \item \code{best_total_energy}: Numeric, the lowest total energy achieved.
  }
}
\description{
Performs optimization to balance fidelity to a target matrix and orthogonality
of the solution matrix using a weighted objective function. The function supports multiple retraction methods and includes robust convergence checks.  These constraints provide global control over column-wise sparseness by projecting the matrix onto the approximate Stiefel manifold.
}
\details{
The function minimizes a weighted objective combining fidelity to \code{X0} and
orthogonality of \code{Y}, defined as:
\deqn{E(Y) = (1 - w) * ||Y - X0||_F^2 / (2 * p * k) + w * defect(Y)}
where \code{defect(Y)} measures orthogonality deviation.

The optimization uses a Riemannian gradient descent approach with optional
retraction to enforce orthogonality constraints. Convergence is checked via
relative gradient norm and energy stability over a window of iterations.
}
\examples{
set.seed(123)
Y0 <- matrix(runif(20), 5, 4)
X0 <- matrix(runif(20), 5, 4)
# The original function relies on helper functions not shown here, such as:
# create_optimizer, step, inv_sqrt_sym, symm, and invariant_orthogonality_defect.
# The following example is conceptual:
# result <- nsa_flow(Y0, X0, w = 0.0, max_iter = 10, verbose = TRUE, plot = TRUE)
# print(result$plot)
# print(result$traces)

}
