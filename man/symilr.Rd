% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiscaleSVDxpts.R
\name{symilr}
\alias{symilr}
\title{Symmetric multivariate, penalized image-based linear regression model (symilr) for N modalities}
\usage{
symilr(voxmats, smoothingMatrices, iterations = 10, gamma = 1.5,
  sparsenessQuantiles, positivities, initialUMatrix, orthogonalize = TRUE,
  repeatedMeasures = NA, verbose = FALSE)
}
\arguments{
\item{voxmats}{A list that contains the named matrices.  Note: the optimization will likely perform much more smoothly if the input matrices are each scaled to zero mean unit variance e.g. by the \code{scale} function.}

\item{smoothingMatrices}{list of (sparse) matrices that allow parameter smoothing/regularization.  These should be square and same order and size of input matrices.}

\item{iterations}{number of gradient descent iterations}

\item{gamma}{step size for gradient descent.  gamma can be of length n-matrices to control the speed of gradient descent per modality.  it is reasonable to simply set this to 1 and allow automated gradient step scaling to work out the practical value.  Set verbose mode to get feedback.}

\item{sparsenessQuantiles}{vector of quantiles to control sparseness - higher is sparser}

\item{positivities}{vector that sets for each matrix if we restrict to positive or negative solution (beta) weights.
choices are positive, negative or either as expressed as a string.}

\item{initialUMatrix}{list of initialization matrix size \code{n} by \code{k} for each modality.  Otherwise, pass a single scalar to control the
number of basis functions in which case random initialization occurs.
If this is set to a scalar, or is missing, a random matrix will be used.}

\item{orthogonalize}{boolean to control whether we orthogonalize the solutions explicitly}

\item{repeatedMeasures}{list of repeated measurement identifiers. this will
allow estimates of per identifier intercept.}

\item{verbose}{boolean to control verbosity of output}
}
\value{
A list of u, x, y, z etc related matrices.
}
\description{
This function simplifies calculating image-wide multivariate beta maps from
that is similar to CCA.
}
\examples{

set.seed(1500)
nsub = 12
npix = 100
outcome = rnorm( nsub )
covar = rnorm( nsub )
mat = replicate( npix, rnorm( nsub ) )
mat2 = replicate( npix + 10, rnorm( nsub ) )
mat3 = replicate( npix + 10, rnorm( nsub ) )
nk = 3
result = symilr(
  list( vox = mat, vox2 = mat2, vox3 = mat3 ), initialUMatrix = nk  )

}
\seealso{
\code{\link{milr}} \code{\link{mild}} \code{\link{symilr2}}
}
\author{
BB Avants.
}
