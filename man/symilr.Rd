% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiscaleSVDxpts.R
\name{symilr}
\alias{symilr}
\title{Symmetric multivariate, penalized image-based linear regression model (symilr) for N modalities}
\usage{
symilr(voxmats, smoothingMatrices, iterations = 10, sparsenessQuantiles,
  positivities, initialUMatrix, mixAlg, orthogonalize = TRUE,
  repeatedMeasures = NA, lineSearchRange = c(-10, 10),
  lineSearchTolerance = 0.001, verbose = FALSE)
}
\arguments{
\item{voxmats}{A list that contains the named matrices.  Note: the optimization will likely perform much more smoothly if the input matrices are each scaled to zero mean unit variance e.g. by the \code{scale} function.}

\item{smoothingMatrices}{list of (sparse) matrices that allow parameter smoothing/regularization.  These should be square and same order and size of input matrices.}

\item{iterations}{number of gradient descent iterations}

\item{sparsenessQuantiles}{vector of quantiles to control sparseness - higher is sparser}

\item{positivities}{vector that sets for each matrix if we restrict to positive or negative solution (beta) weights.
choices are positive, negative or either as expressed as a string.}

\item{initialUMatrix}{list of initialization matrix size \code{n} by \code{k} for each modality.  Otherwise, pass a single scalar to control the
number of basis functions in which case random initialization occurs.
If this is set to a scalar, or is missing, a random matrix will be used.}

\item{mixAlg}{'svd', 'ica' or 'avg' denotes the algorithm mixing bases}

\item{orthogonalize}{boolean to control whether we orthogonalize the solutions explicitly}

\item{repeatedMeasures}{list of repeated measurement identifiers. this will
allow estimates of per identifier intercept.}

\item{lineSearchRange}{lower and upper limit used in \code{optimize}}

\item{lineSearchTolerance}{tolerance used in \code{optimize}, will be multiplied by each matrix norm such that it scales appropriately with input data}

\item{verbose}{boolean to control verbosity of output}
}
\value{
A list of u, x, y, z etc related matrices.
}
\description{
This function simplifies calculating image-wide multivariate beta maps from
that is similar to CCA.
}
\examples{

set.seed(1500)
nsub = 12
npix = 100
outcome = rnorm( nsub )
covar = rnorm( nsub )
mat = replicate( npix, rnorm( nsub ) )
mat2 = replicate( npix + 10, rnorm( nsub ) )
mat3 = replicate( npix + 10, rnorm( nsub ) )
nk = 3
result = symilr(
  list( vox = mat, vox2 = mat2, vox3 = mat3 ), initialUMatrix = nk  )

\dontrun{
# compare to permuted data
s1 = sample( 1:nrow(mat))
s2 = sample( 1:nrow(mat))
result = symilr(list( vox = mat, vox2 = mat2[s1,], vox3 = mat3[s2,] ),
   initialUMatrix = nk , verbose=T, iterations=15  )
p1 = mat \%*\% (result$v[[1]])
p2 = mat2 \%*\% (result$v[[2]])
p3 = mat3 \%*\% (result$v[[3]])
diag(cor(p1,p2))
diag(cor(p1,p3))
diag(cor(p3,p2))

# compare to SVD
svd1 = svd( mat, nu=nk, nv=0 )$u
svd2 = svd( mat2, nu=nk, nv=0 )$u
svd3 = svd( mat3, nu=nk, nv=0 )$u
print( cor( svd1,svd2) )
}
}
\seealso{
\code{\link{milr}} \code{\link{mild}} \code{\link{symilr2}}
}
\author{
BB Avants.
}
