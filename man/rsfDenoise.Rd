% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/rsfDenoise.R
\name{rsfDenoise}
\alias{rsfDenoise}
\title{WIP: data-driven denoising for resting state fMRI}
\usage{
rsfDenoise(boldmatrix, targety, motionparams = NA, selectionthresh = 0.1,
  maxnoisepreds = 1:12, debug = FALSE, polydegree = 4,
  crossvalidationgroups = 4, tr = 1, scalemat = F, noisepoolfun = max)
}
\arguments{
\item{boldmatrix}{input bold matrix}

\item{targety}{target to predict}

\item{motionparams}{motion parameters / nuisance variables}

\item{selectionthresh}{e.g. 0.1 take 10 percent worst variables for noise
estimation}

\item{maxnoisepreds}{integer search range e.g 1:10}

\item{debug}{boolean}

\item{polydegree}{eg 4 for polynomial nuisance variables}

\item{crossvalidationgroups}{prior defined or integer valued}

\item{tr}{bold tr}

\item{scalemat}{boolean}

\item{noisepoolfun}{function to help select noise pool e.g. max}
}
\value{
matrix is output
}
\description{
Uses a target function to denoise resting bold data
}
\examples{
\dontrun{
# simplest approach - load the bold & a mask, then denoise
bold<-antsImageRead("bold.nii.gz",4)
avgbold<-getAverageOfTimeSeries(bold)
boldmask<-getMask( avgbold, lowThresh=mean(avgbold), cleanup=TRUE )
roimask<-antsImageRead("roi.nii.gz",3)
timeselect<-10:(dim(bold)[4]-10)
# can do this if you like its approach
cleanfMRI <- antsPreprocessfMRI( bold, maskImage=boldmask,
  frequencyLowThreshold = 0.01, frequencyHighThreshold = 0.1,
  spatialSmoothingType = "gaussian", spatialSmoothingParameters = 2,
  residualizeMatrix=TRUE, numberOfCompCorComponents=2 )
boldmat<-timeseries2matrix( cleanfMRI$cleanBoldImage, cleanfMRI$maskImage )
roimat<-timeseries2matrix( cleanfMRI$cleanBoldImage, roimask )
roimean<-rowMeans( roimat ) # svd instead?
roimat<-matrix( roimean, ncol=1)
dnz<-rsfDenoise( boldmat[timeselect,] , roimat[timeselect,1], motionparams=NA,
  polydegree=1, crossvalidationgroups = 8, maxnoisepreds=c(2:4), debug=F )
# might iterate over above to further refine noise variables
mdl<-bigLMStats( lm( boldmat[timeselect,] ~ roimean[timeselect] +
   dnz$polys + dnz$noiseu  ), 0.001 )
betas<-mdl$beta.t[1,]
sum(betas[betas > 3])
betaimg<-antsImageClone( boldmask )
betaimg[ boldmask == 1 ]<-betas
antsImageWrite( betaimg, "betas2.nii.gz" )

# more complex
bold<-antsImageRead("bold.nii.gz",4)
boldmask<-antsImageRead("meanboldmask.nii.gz",3)
aalimg<-antsImageRead("meanboldAALmask.nii.gz",3)
data("aal",package="ANTsR")
dmnlabels<-aal$label_num[aal$isdmn>0]
aalvec<-aalimg > 0
whichregion<-3
for ( i in 1:max(aalimg) )
  {
  if ( ! ( i \%in\% dmnlabels[whichregion] ) )
    {
    aalimg[ aalimg == as.numeric(i) ]<-0
    }
  }
maskvec<-boldmask > 0 & aalimg == whichregion
boldmask[ maskvec ]<-0
timeselect<-10:dim(bold)[4]
if ( ! exists("moco") ) {
  moco<-motion_correction(bold,moreaccurate=1)
  moco<-as.matrix( moco$moco_params )[timeselect,3:ncol(moco$moco_params)]
}
boldmat<-timeseries2matrix(bold,boldmask)
boldmat<-boldmat[timeselect,]
aalimg[aalimg > 0 ]<-1
dmnvec<-rowMeans(timeseries2matrix(bold,aalimg))[timeselect]
dmnvec<-(stl(ts(dmnvec, frequency = 4),"per")$time.series)[,2]
dmnvec2<-(stl(ts(dmnvec, frequency = 100),"per")$time.series)[,2]
dmnvec<-ts(as.numeric(dmnvec)-as.numeric(dmnvec2))
dmnmat<-matrix( dmnvec, ncol=1)
dnz<-rsfDenoise( boldmat , dmnmat[,1], motionparams=moco, polydegree=4,
                crossvalidationgroups = 8, maxnoisepreds=1:4, debug=F )
print(paste("Best number of noise regressors",dnz$n))
# now recompute the matrix using the full mask
boldmask<-antsImageRead("meanboldmask.nii.gz",3)
boldmat<-timeseries2matrix(bold,boldmask)
boldmat<-boldmat[timeselect,]
mdl<-bigLMStats( lm( boldmat ~ dmnmat[,1] + dnz$polys + dnz$noiseu ), 0.001 )
betas<-mdl$beta.t[1,]
}
}
\author{
Avants BB
}

