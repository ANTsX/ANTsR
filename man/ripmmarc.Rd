% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ripmmarc.R
\name{ripmmarc}
\alias{ripmmarc}
\title{Rotation Invariant Patch-based Multi-Modality Analysis aRChitecture}
\usage{
ripmmarc(img, mask, patchRadius = 3, patchSamples = 1000,
  patchVarEx = 0.95, meanCenter = FALSE, canonicalFrame = NA,
  evecBasis = NA, rotationInvariant = TRUE, verbose = FALSE)
}
\arguments{
\item{img}{Image to decompose}

\item{mask}{Binary mask defining regions in which to decompose.}

\item{patchRadius}{Scalar radius defining the patch size.}

\item{patchSamples}{Scalar defining the number of random patches to sample.}

\item{patchVarEx}{Scalar defining the target variance explained.  If this is
greater than one, then it defines the number of eigenvectors.  Otherwise, it
defines the target variance explained.}

\item{meanCenter}{boolean whether we mean center the patches.}

\item{canonicalFrame}{pass in an existing canonicalFrame.}

\item{evecBasis}{pass in an existing eigenvector basis.}

\item{rotationInvariant}{boolean sets whether patches are rotationInvariant.}

\item{verbose}{boolean sets verbosity.}
}
\value{
list including the canonical frame, the matrix basis, the patches for
the full image, the projection coefficients for the full image, the
variance explained and a reconstructed image.
}
\description{
Patch-based and rotation invariant image decomposition.  This
is similar to patch-based dictionary learning in N-dimensions.
}
\examples{
img <- antsImageRead( getANTsRData( "r16" ) )
msk <- thresholdImage( img, quantile( img[ img > 0 ] )[1], max( img ) )
ripped <- ripmmarc( img, msk, patchRadius=3, patchSamples=2000, patchVarEx=0.95  )
# img[ msk == 1 ] = ripped$evecCoeffs[2,]; plot( img )
ripped <- ripmmarc( img, msk, patchRadius=3, patchSamples=2000, patchVarEx=4  )
ripped2 <- ripmmarc( img, msk, patchRadius=3, patchSamples=2000,
  canonicalFrame = ripped$canonicalFrame,
  evecBasis = ripped$basisMat )
\dontrun{
ch2 = antsImageRead( getANTsRData( 'ch2' ) )
msk2 <- thresholdImage( ch2, quantile( ch2[ ch2 > 0 ] )[1], max( ch2 ) ) \%>\%
  iMath( "ME", 30 )
ripped <- ripmmarc( ch2, msk2, patchRadius=5, patchSamples=1000,
  meanCenter = TRUE, patchVarEx=10, verbose=TRUE )
mm = thresholdImage( abs( ripped$canonicalFrame ), 1.e-20, Inf )
mm2 = antsImageClone( mm )
ch2ev = ch2 * 0
k = 7
ch2ev[ msk2 == 1 ] =  ripped$evecCoeffs[ , k]
plot( ch2ev, doCropping=F, slices=90 )
mm2[ mm == 1 ] = ripped$basisMat[k,]
ripped <- ripmmarc( img, msk, patchRadius=3, patchSamples=2000, patchVarEx=10 )
mm = thresholdImage( abs( ripped$canonicalFrame ), 1.e-20, Inf )
mm2 = antsImageClone( mm )
for (k in 1:nrow( ripped$basisMat ) ) {
  mm2[mm==1] =  ripped$basisMat[k,]
  plot( mm2, doCropping=F )
  }
}
}
\author{
Kandel BM, Avants BB
}

