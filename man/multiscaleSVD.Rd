% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiscaleSVDxpts.R
\name{multiscaleSVD}
\alias{multiscaleSVD}
\title{Multi-scale svd}
\usage{
multiscaleSVD(x, r, locn, nev, knn = 0, verbose = FALSE, plot = 0)
}
\arguments{
\item{x}{input matrix, should be n (samples) by p (measurements)}

\item{r}{radii to explore}

\item{locn}{number of local samples to take at each scale}

\item{nev}{maximum number of eigenvalues to compute}

\item{knn}{randomly sample neighbors to assist with large datasets. set k with this value.}

\item{verbose}{boolean to control verbosity of output}

\item{plot}{boolean to control whether we plot results.  its value determines
which eigenvector off which to base the scale of the y-axis.'}
}
\value{
dataframe containing the estimated eigenvalues across scale
}
\description{
Maggioni's multi-scale SVD algorithm explores the dimensionality of a dataset
by investigating the change in eigenvalues with respect to a scale parameter.
The scale parameter is defined by the radius of a ball that sits at each
point in the data.  The ball, at each scale, is moved across the dataset
and SVD is computed within the intersection of the ball and the data at each
point.  The shape in this collection of eigenvalues, with respect to scale,
enables us to estimate both signal and noise dimensionality and scale.  The
estimate can be computed efficiently on large datasets if the sampling is
chosen appropriately.
}
\examples{

sphereDim = 9
embeddDim = 100
n = 1000
sphereData = pracma::rands( n, sphereDim, 1. )
mysig = 0.1
spherEmbed = matrix( rnorm( n * embeddDim, 0, mysig ), nrow = n, ncol = embeddDim )
spherEmbed[ , 1:ncol( sphereData ) ] = spherEmbed[ , 1:ncol( sphereData ) ] + sphereData
myr = seq( 1.0, 2.2, 0.05 ) # scales at which to sample
mymssvd = multiscaleSVD( spherEmbed, myr, locn=5, nev=20, plot=1 )

}
\author{
Avants BB
}
\references{
\url{http://www.math.jhu.edu/~mauro/multiscaledatageometry.html}
}

