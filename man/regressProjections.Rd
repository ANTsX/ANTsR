% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/regressProjections.R
\name{regressProjections}
\alias{regressProjections}
\title{Regression on image set projection}
\usage{
regressProjections(
  input.train,
  input.test,
  demog.train,
  demog.test,
  eigenvectors,
  mask,
  outcome,
  covariates = "1",
  model.function = glm,
  which.eigenvectors = "all",
  ...
)
}
\arguments{
\item{input.train}{Masked imaging data from training set of type
\code{antsImage} or \code{matrix}.  This will typically be read from a
\code{train.mha} file generated by, e.g., \code{sccan --imageset-to-matrix}.}

\item{input.test}{Masked imaging data from testing set of type
\code{antsImage} or \code{matrix}.  This will typically be read from a
\code{test.mha} file generated by, e.g., \code{sccan --imageset-to-matrix}.}

\item{demog.train}{Data frame of demographics information for training
images.}

\item{demog.test}{Data frame of demographics information for testing images.}

\item{eigenvectors}{List of eigenvector images for dimensionality reduction.}

\item{mask}{Mask image of type \code{antsImage}.}

\item{outcome}{Name of outcome variable to be predicted.  Must be present in
\code{demog.train} and \code{demog.test}.}

\item{covariates}{List of names of covariates to be used for the prediction.
All names must be present in \code{demog.train} and \code{demog.test}.}

\item{model.function}{Modeling function for predicting outcome from input
data.  Can be any function that has \code{formula} and \code{data} arguments
and a \code{predict} method.  Defaults to \code{glm}, but svm, randomForest,
etc. will also work (assuming necessary libraries are loaded).}

\item{which.eigenvectors}{Method for selecting eigenvectors.  Can be either
\code{'all'} (uses all eigenvectors in \code{vector.names}) or
\code{'optimal'} (uses BIC stepwise model selection to select eigenvectors).
\code{'optimal'} only works for \code{model.function} arguments that include
an \code{extractAIC} method and a \code{coefficients} attribute.}

\item{...}{Additional arguments for input to \code{model.function}.  Example
input would be \code{family=binomial} for classification instead of
regression when using \code{glm}.}
}
\value{
A list of diagnostic and statistical information generated from the
prediction, including: \code{stats}: Statistics on computed fits.  For
numeric outcomes, mean squared error, correlation coefficients, and p-value
of prediction for training and testing data.  For factor outcomes,
misclassification rate and p-value of classification model.
\code{outcome.comparison}: Data frame comparing real vs. predicted values
for testing data.  \code{eigenvectors}: List of eigenvectors retained in
model building.
}
\description{
Perform regression on a training set of images, projected onto (provided)
eigenvectors, and test on testing images.
}
\details{
\code{regressProjections} is a convenient way to perform training and
testing of predictions of demographic information from imaging data.  It
takes as input demographics information, imaging data, and eigenvectors, and
performs prediction of the outcome variable from the projection of the
imaging data on the eigenvectors.
}
\examples{

# generate simulated outcome
nsubjects <- 100
x1 <- seq(1, 10, length.out=nsubjects) + rnorm(nsubjects, sd=2)
x2 <- seq(25, 15, length.out=nsubjects) + rnorm(nsubjects, sd=2)
outcome <- 3 * x1 + 4 * x2 + rnorm(nsubjects, sd=1)
# generate simulated images with outcome predicted
# by sparse subset of voxels
voxel.1 <- 3 * x1 + rnorm(nsubjects, sd=2)
voxel.2 <- rnorm(nsubjects, sd=2)
voxel.3 <- 2 * x2 + rnorm(nsubjects, sd=2)
voxel.4 <- rnorm(nsubjects, sd=3)
input   <- cbind(voxel.1, voxel.2, voxel.3, voxel.4)
# simulate eigenvectors and mask
mydecom <- sparseDecom(input, sparseness=0.25, nvecs=4)
mask    <- as.antsImage(matrix(c(1,1,1,1), nrow=2))
# generate sample demographics that do not explain outcome
age <- runif(nsubjects, 50, 75)
demog <- data.frame(outcome=outcome, age=age)
# randomly divide data into training and testing
data.split <- splitData(demog, 2/3, return.rows=TRUE)
eanatimages <- matrixToImages( mydecom$eig, mask )
result <- regressProjections(input[data.split$rows.in, ],
  input[data.split$rows.out, ],
  data.split$data.in, data.split$data.out,
  eanatimages,
  mask, 'outcome')

}
\seealso{
\code{\link{sparseDecom2}}
}
\author{
Kandel BM and Avants B
}
