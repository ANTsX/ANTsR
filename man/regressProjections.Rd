\name{regressProjections}
\alias{regressProjections}
\title{
Regression on image set projection
}
\description{
  Perform regression on a training set of images, projected onto (provided) eigenvectors, and test on testing images.
}

\usage{
  regressProjections(input.train, input.test, demog.train, demog.test, 
           eigenvectors, mask, outcome, covariates="1", model.function=glm, 
	   which.eigenvectors="all", ...)
}

\arguments{
  \item{input.train}{Masked imaging data from training set of type \code{antsImage} or \code{matrix}.  This will typically be read from a \code{train.mha} file generated by, e.g., \code{sccan --imageset-to-matrix}.}
  \item{input.test}{Masked imaging data from testing set of type \code{antsImage} or \code{matrix}.  This will typically be read from a \code{test.mha} file generated by, e.g., \code{sccan --imageset-to-matrix}.}
  \item{demog.train}{Data frame of demographics information for training images.}
  \item{demog.test}{Data frame of demographics information for testing images.}
  \item{eigenvectors}{List of eigenvector images for dimensionality reduction.}
  \item{mask}{Mask image of type \code{antsImage}.}
  \item{outcome}{Name of outcome variable to be predicted.  Must be present in \code{demog.train} and \code{demog.test}.}
  \item{covariates}{List of names of covariates to be used for the prediction.  All names must be present in \code{demog.train} and \code{demog.test}.}
  \item{model.function}{Modeling function for predicting outcome from input data.  Can be any function that has \code{formula} and \code{data} arguments and a
  \code{predict} method.  Defaults to \code{glm}, but svm, randomForest, etc. will also work (assuming necessary libraries are loaded).}
  \item{which.eigenvectors}{Method for selecting eigenvectors.  Can be either \code{"all"} (uses all eigenvectors in \code{vector.names}) or
  \code{"optimal"} (uses BIC stepwise model selection to select eigenvectors).  \code{"optimal"} only works for \code{model.function} arguments that
  include an \code{extractAIC} method and a \code{coefficients} attribute.}
  \item{...}{Additional arguments for input to \code{model.function}.  Example input would be \code{family=binomial} for classification instead of
  regression when using \code{glm}.}
}

\details{
\code{regressProjections} is a convenient way to perform training and testing of predictions of demographic information from imaging data.  It takes as
input demographics information, imaging data, and eigenvectors, and performs prediction of the outcome variable from the projection of the imaging data on
the eigenvectors. 
}

\value{
A list of diagnostic and statistical information generated from the prediction, including: 
  \code{stats}: Statistics on computed fits.  For numeric outcomes, mean squared error, correlation coefficients, and p-value of prediction for training
  and testing data.  For factor outcomes, misclassification rate and p-value of classification model.
  \code{outcome.comparison}: Data frame comparing real vs. predicted values for testing data. 
  \code{eigenvectors}: List of eigenvectors retained in model building. 
}

\seealso{
  \code{\link{sparseDecom2}}
}

\author{
Kandel BM and Avants B
}

\examples{
# generate simulated outcome
nsubjects <- 100
x1 <- seq(1, 10, length.out=nsubjects) + rnorm(nsubjects, sd=2)
x2 <- seq(25, 15, length.out=nsubjects) + rnorm(nsubjects, sd=2)
outcome <- 3 * x1 + 4 * x2 + rnorm(nsubjects, sd=1)
# generate simulated images with outcome predicted 
# by sparse subset of voxels
voxel.1 <- 3 * x1 + rnorm(nsubjects, sd=2)
voxel.2 <- rnorm(nsubjects, sd=2)
voxel.3 <- 2 * x2 + rnorm(nsubjects, sd=2)
voxel.4 <- rnorm(nsubjects, sd=3)
input   <- cbind(voxel.1, voxel.2, voxel.3, voxel.4)
# simulate eigenvectors and mask
mydecom <- sparseDecom(input, sparseness=0.25, nvecs=4) 
mask    <- as.antsImage(matrix(c(1,1,1,1), nrow=2))
# generate sample demographics that do not explain outcome
age <- runif(nsubjects, 50, 75)
demog <- data.frame(outcome=outcome, age=age)
# randomly divide data into training and testing 
data.split <- splitData(demog, 2/3, return.rows=TRUE)
result <- regressProjections(input[data.split$rows.in, ], input[data.split$rows.out, ], 
            data.split$data.in, data.split$data.out, mydecom$eigenanatomyimages, 
	    mask, "outcome")
}
