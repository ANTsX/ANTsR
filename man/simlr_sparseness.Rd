% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiscaleSVDxpts.R
\name{simlr_sparseness}
\alias{simlr_sparseness}
\title{Apply SIMLR Sparseness and Normalize Features}
\usage{
simlr_sparseness(
  v,
  constraint_type = c("Stiefel", "Grassmann", "none", "ortho"),
  smoothing_matrix = NULL,
  positivity = "positive",
  sparseness_quantile = 0.8,
  constraint_weight = NA,
  constraint_iterations = 10,
  sparseness_alg = NA,
  energy_type = "acc"
)
}
\arguments{
\item{v}{A numeric matrix or vector to be transformed.}

\item{constraint_type}{Character. Type of manifold constraint; one of `"Stiefel"`, `"Grassmann"`, or `"None"`.}

\item{smoothing_matrix}{Optional numeric matrix. If provided, \code{v} is left-multiplied by this matrix.}

\item{positivity}{Character positive, negative or either.}

\item{sparseness_quantile}{Numeric between 0 and 1. Fraction of elements to sparsify using quantile thresholding.}

\item{constraint_weight}{Numeric. Weight for the constraint, used in orthogonalization.}

\item{constraint_iterations}{Numeric. Number of iterations for the orthogonalization optimization.}

\item{sparseness_alg}{Character. Sparsity algorithm to use (passed to \code{orthogonalizeAndQSparsify}).}

\item{energy_type}{Character. If set to one of `"acc"`, `"cca"`, `"nc"`, `"normalized_correlation"`, `"lowRankRegression"`, or `"lrr"`,
then the returned matrix is normalized using \code{l1_normalize_features}.}
}
\value{
A numeric matrix of the same dimensions as \code{v}, with applied smoothing, sparsity, and optional normalization.
}
\description{
Applies smoothing and sparsity constraints to a matrix or vector as used in SIMLR or manifold learning,
followed by optional L1 feature normalization depending on the energy type.
}
\examples{
v <- matrix(rnorm(100), nrow = 10)
L <- diag(10) # Identity as placeholder smoothing matrix
simlr_sparseness(v, constraint_type = "Stiefel", smoothing_matrix = L, positivity = 0.8, energy_type = "cca")
}
