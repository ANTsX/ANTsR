Tips for functional MRI and resting state analysis
==================================================

First take a quick look at your data.

.. {r plotANTsfImage, out.width='720px', fig.cap='ANTsR fMRI plot',eval=TRUE,echo=TRUE,warning=FALSE,results='hide',message=FALSE}
library(ANTsR)
pixtype<-"double" # needed for call to antsMotionCorr
fn<-"KKI2009-01-fMRI.nii.gz" # 4D image 
glb <- glob2rx(paste(fn, sep = ""))
fn <- list.files(path = "../../", pattern = glb, full.names = T, recursive = T)[1]
img<-antsImageRead(fn,4,pixtype)
#' get the average to look at it in 3D
avg <- new( "antsImage" , dimension = 3 , pixeltype=img@pixeltype  )
antsMotionCorr( list( d = 3 , a = img , o = avg ) )
#' look at the header to determine slices to display 
ImageMath('4','na','PH',img)
plotANTsImage(myantsimage=avg,slices="12x33x3",axis=3)
.. ..

The data looks ok so now convert the rsf image to a frequency filtered matrix.  

This involves motion correction which, with default settings, can be time consuming (because we are being careful).  Here, we speed things up by setting moreaccurate=:r:`FALSE` (not recommended).

We also estimate a brain mask and nuisance pararmeters including global signal, physiological and motion confounds.  See :r:`?filterfMRIforNetworkAnalysis` .

.. {r fmriprocess, out.width='720px', fig.cap='ANTsR preprocessing, including frequency filtering, for fMRI',eval=TRUE,echo=TRUE,warning=FALSE,results='hide',message=FALSE}
myres<-filterfMRIforNetworkAnalysis(img,tr=4,0.03,0.09,cbfnetwork="BOLD",smoother=1,moreaccurate=FALSE,maskThresh=100000)
# check if the mask is ok
plotANTsImage(myantsimage=avg,functional=myres$mask,slices="12x33x3",axis=3,threshold="0.5x1.5")
# The mask looks fine ( does not have to be perfect ) so we proceed.
.. .. 


.. {r stealmultiplot, out.width='720px',echo=FALSE,eval=TRUE,warning=FALSE,results='hide',message=FALSE}
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  require(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
.. .. 

The stage above factored out what many consider to be the major signals in fMRI that are not due to natural resting-state fluctuations in brain activity.  

A network analysis may now be performed on the results of the above processing.  The key output is myres$filteredTimeSeries.  Let's look at sample voxels' time series using basic plotting.

.. {r plotsamplevoxels, out.width='720px', fig.cap='ANTsR sample voxels',eval=TRUE,echo=TRUE,warning=FALSE,results='hide',message=FALSE}
library(ggplot2)
samplevox1<-round( ncol(myres$filteredTimeSeries)/2 )
samplevox2<-round( ncol(myres$filteredTimeSeries)/3 )
data<-data.frame( time = c(1:nrow( myres$filteredTimeSeries ) )*4 , v1 = myres$filteredTimeSeries[ ,samplevox1] , v2 = myres$filteredTimeSeries[ ,samplevox2]  )
p1<-( ggplot( data , aes( x = time , y = v1 ) ) + geom_line()  + ggtitle("Time series @ voxel 1") )
p2<-( ggplot( data , aes( x = time , y = v2 ) ) + geom_line()  + ggtitle("Time series @ voxel 2") )
multiplot( p1, p2, cols=1) # function stolen from the internet
.. ..

That's good --- check a separate page for example network analyses.  In brief, a network analysis will compute correlations between voxels such as these.  

Let’s simulate a standard rsf network analysis by extracting some data-driven “ROIs” and show the resulting correlation matrix.


.. {r simplesparsesvd, out.width='720px', fig.cap='ANTsR rsfmri correlations from simple sparse svd',eval=TRUE,echo=TRUE,warning=FALSE,results='hide',message=FALSE}
mysvd <- svd(myres$filteredTimeSeries)
# let's make the v eigenvectors sparse , otherwise they are totally uncorrelated
nevecs <- 10
vecs <- mysvd$v[, 1:nevecs]
thresh <- 0.005  # just an example
for (i in c(1:nevecs)) {
    vecs[, i] <- (vecs[, i] * (vecs[, i] > thresh))
    vecimg <- antsImageClone(myres$mask, "float")
    mask <- antsImageClone(myres$mask, "float")
    vecimg[(myres$mask > 0)] <- vecs[, i]
    ImageMath("3", vecimg, "ClusterThresholdVariate", vecimg, mask, "100")
    vecs[, i] <- vecimg[(myres$mask > 0)]
}
tobecorrelated <- (myres$filteredTimeSeries %*% vecs)
#' visualize the resulting correlations
image(cor(tobecorrelated))
.. ..

The correlation matrix is the most frequently used basis of rsf-MRI analysis.

Now you can reduce your fMRI data to relatively simple measurements of connectivity. Congratulations!

ToDo: add gray matter mask and anatomical labels.

.. {r testrestingstatefMRIconnectivity, out.width='720px', fig.cap='ANTsR rsfmri correlations from simple sparse svd',eval=TRUE,echo=FALSE,warning=FALSE,results='markup',message=FALSE}
isucceed<-FALSE
if ( round(mean(cor(tobecorrelated))*100) == 22 ) isucceed<-TRUE
if (  isucceed ) print("SUCCESS")
if ( !isucceed ) print("FAILURE")
.. .. 

