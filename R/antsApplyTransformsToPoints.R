#' Apply transforms to points.
#'
#' Apply a transform list to map a pointset from one domain to another. In
#' registration, one computes mappings between pairs of domains.
#' These transforms are often a sequence of increasingly complex maps, e.g.
#' from translation, to rigid, to affine to deformation.  The list of such
#' transforms is passed to this function to interpolate one image domain
#' into the next image domain, as below.  The order matters strongly and the
#' user is advised to familiarize with the standards established in examples.
#' Importantly, point mapping goes the opposite direction of image mapping,
#' for both reasons of convention and engineering.
#'
#' @param dim dimensionality of the transformation.
#' @param points moving point set with n-points in rows of at least dim
#' columns - we maintain extra information in additional columns. this
#' may be either a dataframe or a 2D antsImage - the latter may be better
#' for large pointsets.
#' @param transformlist list of transforms generated by
#' antsRegistration where each transform is a filename.
#' @param whichtoinvert list of booleans, same length as transforms
#' @return same type as input. 1 -- Failure
#' @author Avants BB
#' @examples
#'
#' fixed <- antsImageRead( getANTsRData("r16") ,2)
#' moving <- antsImageRead( getANTsRData("r64") ,2)
#' fixed <- resampleImage(fixed,c(64,64),1,0)
#' moving <- resampleImage(moving,c(64,64),1,0)
#' mytx <- antsRegistration(fixed=fixed , moving=moving ,
#'   typeofTransform = c("SyN") )
#' pts=data.frame(  x=c(110.5,120,130) , y=c(108.1,121.0,130),
#'   label=c(1,2,3) )
#' wpts <- antsApplyTransformsToPoints( dim=2, points=pts,
#'   transformlist=mytx$fwdtransforms )
#'
#' @seealso \code{\link{antsRegistration}}
#' @export antsApplyTransformsToPoints
antsApplyTransformsToPoints <- function(
  dim,
  points,
  transformlist = "",
  whichtoinvert = NA )
{
  ttexists <- TRUE
  for (i in 1:length(transformlist))
    {
    if ( ! file.exists( transformlist[i] ) ) ttexists <- FALSE
    }
  if (ttexists)
    {
    inpixeltype <- fixed@pixeltype
    warpedmovout <- antsImageClone(moving)
    f <- fixed
    m <- moving
    wmo <- warpedmovout
    mytx <- list()
    if (all(is.na(whichtoinvert)))
      {
      whichtoinvert <- rep(F, length(transformlist))
      }
    for (i in c(1:length(transformlist)))
      {
      ismat <- FALSE
      if ((i == 1 & length(transformlist) > 1) |
        whichtoinvert[i] == TRUE)
        {
        if (length(grep(".mat", transformlist[i])) == 1)
          {
          ismat <- TRUE
          }
        }
        if (!ismat)
          {
          mytx <- list(mytx, "-t", transformlist[i])
          } else if (ismat) {
            mytx <- list( mytx, "-t",
              paste("[", transformlist[i], ",1]", sep = "") )
          }
      }
    if ( class(points)[[1]] != "antsImage" )
      usepts = as.antsImage( as.matrix(points) ) else usepts = ( points )
    if ( usepts@dimension != 2 ) stop("must be 2d antsImage")
    pointsout = antsImageClone( points )
    args <- list( d = dim, i = usepts, o = pointsout, unlist(mytx) )
    myargs <- .int_antsProcessArguments(c(args))
    for (jj in c(1:length(myargs))) {
          if (!is.na(myargs[jj])) {
          if (myargs[jj] == "-") {
            myargs2 <- rep(NA, (length(myargs) - 1))
            myargs2[1:(jj - 1)] <- myargs[1:(jj - 1)]
            myargs2[jj:(length(myargs) - 1)] <- myargs[(jj + 1):(length(myargs))]
            myargs <- myargs2
          }
          }
        }
    .Call("antsApplyTransformsToPoints",
         c(myargs, "-f", 1, "--precision", 0, PACKAGE = "ANTsR") )
    return( pointsout )
    }
    if (!ttexists)
        stop("transforms may not exist")
}
