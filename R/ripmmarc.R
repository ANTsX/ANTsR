#' @title Rotation Invariant Patch-based Multi-Modality Analysis aRChitecture
#' @description Patch-based and rotation invariant image decomposition.  This
#' is similar to patch-based dictionary learning in N-dimensions.  Warning:
#' there may be an overlow/underflow error in the C++ underlying this function
#' that appears to occur when insufficient \code{patchSamples} are selected.
#' @param img Image to decompose
#' @param mask Binary mask defining regions in which to decompose.
#' @param patchRadius Scalar radius defining the patch size.
#' @param patchSamples Scalar defining the number of random patches to sample.
#' @param patchVarEx Scalar defining the target variance explained.  If this is
#' greater than one, then it defines the number of eigenvectors.  Otherwise, it
#' defines the target variance explained.
#' @param meanCenter boolean whether we mean center the patches.
#' @param canonicalFrame pass in an existing canonicalFrame.
#' @param evecBasis pass in an existing eigenvector basis.
#' @param rotationInvariant boolean sets whether patches are rotationInvariant.
#' @param regressProjections boolean return reconstruction parameters.
#' @param verbose boolean sets verbosity.
#' @return list including the canonical frame, the matrix basis, the patches for
#' the full image, the projection coefficients for the full image, the
#' variance explained and a reconstructed image.
#' @author Kandel BM, Avants BB
#' @examples
#'
#' img <- antsImageRead( getANTsRData( "r16" ) )
#' msk <- getMask( img ) %>% iMath("ME",1)
#' lap = iMath( img, "Laplacian", 2 )
#' mskTestTrain = antsImageClone( msk )
#' mskTestTrain[1:128,1:256]=2
#' mskTestTrain = mskTestTrain * msk
#' pr = 2
#' nv = 15
#' ripped <- ripmmarc( img, thresholdImage(mskTestTrain,2,2), patchRadius=pr,
#'   patchSamples=5000, patchVarEx=nv, rotationInvariant = FALSE )
#' ipatches = ripped$imagePatchMat
#' ibasis   = scale( ripped$basisMat )
#' k = 2233
#' kk = lm( ipatches[k,] ~ t( ibasis[1:10,] ) )
#' rimg = ripmmarcBasisImage( ripped$canonicalFrame, ipatches[k,] )
#' # plot( rimg, doCropping=F )
#' bimg = ripmmarcBasisImage( ripped$canonicalFrame, ibasis[5,] )
#' # plot( bimg, doCropping=F )
#'
#' rippedTest <- ripmmarc( img, thresholdImage(mskTestTrain,1,1), patchRadius=pr,
#'   evecBasis = ripped$basisMat, canonicalFrame = ripped$canonicalFrame,
#'   patchSamples=500, patchVarEx=nv, rotationInvariant = FALSE )
#' lapTrainVox = lap[ mskTestTrain == 2 ]
#' lapTestVox = lap[ mskTestTrain == 1 ]
#' mydftr = data.frame( lap=lapTrainVox, t1feats=ripped$evecCoeffs )
#' mydfte = data.frame( lap=lapTestVox, t1feats=rippedTest$evecCoeffs )
#' mdl = lm( lap ~ . , data = mydftr )
#' preds = predict( mdl, newdata = mydfte )
#' # cor.test( preds, mydfte$lap )
#'
#' @export
ripmmarc <- function(
  img,
  mask,
  patchRadius = 3,
  patchSamples = 1000,
  patchVarEx   = 0.95,
  meanCenter   = FALSE,
  canonicalFrame = NA,
  evecBasis    = NA,
  rotationInvariant = TRUE,
  regressProjections = TRUE,
  verbose = FALSE  ) {
  print("WARNING: WIP, this implementation of ripmmarc is not validated!!")
  inimg.float <- antsImageClone( img, "float" )
  mask.float <- antsImageClone( mask, "float" )
  outimg <- antsImageClone( inimg.float )
  if ( any( is.na( evecBasis ) ) ) evecBasis = matrix( nrow=0, ncol=0 )
  else if ( !any( is.na( evecBasis ) ) & is.na( canonicalFrame ) )
    stop("The user must also pass in a canonical frame.")
  if ( is.na( canonicalFrame ) ) {
    canonicalFrame = makeImage( rep( 1, img@dimension ), 0 )
  }
  # FIXME not sure why transpose is needed below ....
  outstruct <- .Call("patchAnalysis",
                     inimg.float, mask.float, outimg, patchRadius, 
                     patchSamples, patchVarEx,
                     meanCenter, canonicalFrame, t(evecBasis),
                     rotationInvariant, regressProjections, verbose, 
                     PACKAGE = "ANTsR")
  outstruct[[1]] = antsImageClone( outstruct[[1]], img@pixeltype )
  if ( regressProjections ) {
    mdl = lm( t( outstruct$imagePatchMat) ~ t( outstruct$basisMat  ) )
    bmdl = bigLMStats( mdl, lambda = 1.e-4, includeIntercept = T )
    outstruct$evecCoeffs = t( bmdl$beta )
    mdl = predict( mdl )
    outstruct$recon = makeImage( mask, mdl[ round( nrow( mdl ) / 2 ) + 1, ] )
  }
  invisible( gc() )
  return( outstruct )
}




#' @title Generate an antsImage from ripmmarc basis data
#' @description This function converts a vectorized image patch back into an
#' antsImage such that it may be displayed in its extrinsic dimensionality.
#' @param canonicalFrame canonical frame image generated by ripmmarc
#' @param patchBasisVector the basis vector to convert to image space
#' @param eps small value threshold to help generate mask from canonicalFrame
#' @return antsImage
#' @author Kandel BM, Avants BB
#' @examples
#'
#' img <- antsImageRead( getANTsRData( "r16" ) )
#' msk <- thresholdImage( img, quantile( img[ img > 0 ] )[1], max( img ) )
#' ripped <- ripmmarc( img, msk, patchRadius=3, patchSamples=2000, patchVarEx=5)
#' bimg = ripmmarcBasisImage( ripped$canonicalFrame, ripped$basisMat[4,] )
#'
#' @export
ripmmarcBasisImage <- function( canonicalFrame, 
                                patchBasisVector, eps = 1.e-12)
{
  newimg = canonicalFrame * 0
  frameMask = thresholdImage( abs( canonicalFrame ), eps, Inf )
  if ( sum( frameMask ) != length( patchBasisVector ) )
    stop("Size of mask does not appear to match length of basis vector" )
  newimg[ frameMask == 1 ] = patchBasisVector
  return( newimg )
}
