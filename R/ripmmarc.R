#' @name ripmmarc
#' @title Rotation Invariant Patch-based Multi-Modality Analysis aRChitecture
#' @description Patch-based and rotation invariant image decomposition.  This
#' is similar to patch-based dictionary learning in N-dimensions.  Warning:
#' there may be an overlow/underflow error in the C++ underlying this function
#' that appears to occur when insufficient \code{patchSamples} are selected.
#' @param img Image to decompose
#' @param mask Binary mask defining regions in which to decompose.
#' @param patchRadius Scalar radius defining the patch size.
#' @param patchSamples Scalar defining the number of random patches to sample.
#' @param patchVarEx Scalar defining the target variance explained.  If this is
#' greater than one, then it defines the number of eigenvectors.  Otherwise, it
#' defines the target variance explained.
#' @param meanCenter boolean whether we mean center the patches.
#' @param canonicalFrame pass in an existing canonicalFrame.
#' @param evecBasis pass in an existing eigenvector basis.
#' @param rotationInvariant boolean sets whether patches are rotationInvariant.
#' @param verbose boolean sets verbosity.
#' @return list including the canonical frame, the matrix basis, the patches for
#' the full image, the projection coefficients for the full image, the
#' variance explained and a reconstructed image.
#' @author Kandel BM, Avants BB
#' @examples
#' img <- antsImageRead( getANTsRData( "r16" ) )
#' msk <- thresholdImage( img, quantile( img[ img > 0 ] )[1], max( img ) )
#' ripped <- ripmmarc( img, msk, patchRadius=3, patchSamples=2000, patchVarEx=0.95  )
#' # img[ msk == 1 ] = ripped$evecCoeffs[2,]; plot( img )
#' ripped <- ripmmarc( img, msk, patchRadius=3, patchSamples=2000, patchVarEx=4  )
#' ripped2 <- ripmmarc( img, msk, patchRadius=3, patchSamples=2000,
#'   canonicalFrame = ripped$canonicalFrame,
#'   evecBasis = ripped$basisMat )
#' \dontrun{
#' ch2 = antsImageRead( getANTsRData( 'ch2' ) )
#' msk2 <- thresholdImage( ch2, quantile( ch2[ ch2 > 0 ] )[1], max( ch2 ) ) %>%
#'   iMath( "ME", 30 )
#' ripped <- ripmmarc( ch2, msk2, patchRadius=5, patchSamples=1000,
#'   meanCenter = TRUE, patchVarEx=10, verbose=TRUE )
#' mm = thresholdImage( abs( ripped$canonicalFrame ), 1.e-20, Inf )
#' mm2 = antsImageClone( mm )
#' ch2ev = ch2 * 0
#' k = 7
#' ch2ev[ msk2 == 1 ] =  ripped$evecCoeffs[ , k]
#' plot( ch2ev, doCropping=F, slices=90 )
#' mm2[ mm == 1 ] = ripped$basisMat[k,]
#' ripped <- ripmmarc( img, msk, patchRadius=3, patchSamples=2000, patchVarEx=10 )
#' mm = thresholdImage( abs( ripped$canonicalFrame ), 1.e-20, Inf )
#' mm2 = antsImageClone( mm )
#' for (k in 1:nrow( ripped$basisMat ) ) {
#'   mm2[mm==1] =  ripped$basisMat[k,]
#'   plot( mm2, doCropping=F )
#'   }
#' }
#' @export ripmmarc
ripmmarc <- function(
  img,
  mask,
  patchRadius = 3,
  patchSamples = 1000,
  patchVarEx   = 0.95,
  meanCenter   = FALSE,
  canonicalFrame = NA,
  evecBasis    = NA,
  rotationInvariant = TRUE,
  verbose = FALSE  ) {
  print("WARNING: WIP, this implementation of ripmmarc is not validated!!")
  inimg.float <- antsImageClone( img, "float" )
  mask.float <- antsImageClone( mask, "float" )
  outimg <- antsImageClone( inimg.float )
  if ( any( is.na( evecBasis ) ) ) evecBasis = matrix( nrow=0, ncol=0 )
  else if ( !any( is.na( evecBasis ) ) & is.na( canonicalFrame ) )
    stop("The user must also pass in a canonical frame.")
  if ( is.na( canonicalFrame ) ) {
    canonicalFrame = makeImage( rep( 1, img@dimension ), 0 )
    }
  # FIXME not sure why transpose is needed below ....
  outstruct <- .Call("patchAnalysis",
    inimg.float, mask.float, outimg, patchRadius, patchSamples, patchVarEx,
    meanCenter, canonicalFrame, t(evecBasis),
    rotationInvariant, verbose, PACKAGE = "ANTsR")
  outstruct[[1]] = antsImageClone( outstruct[[1]], img@pixeltype )
  # mdl = lm( t( outstruct$imagePatchMat) ~ t( outstruct$basisMat  ) )
  # bmdl = bigLMStats( mdl, includeIntercept = F )
  # overwrite the C++ patch computation with R results
  # outstruct$evecCoeffs = t( bmdl$beta )
  i1v = img[ mask == 1 ]
  mydf = data.frame( ( outstruct$evecCoeffs  ) )
  mylmdl = glm( i1v ~ . , data=mydf , family = 'gaussian' )
  mypred = img * 0
  mypred[ mask == 1 ] = as.numeric( predict( mylmdl ) )
  outstruct$recon = mypred
  return( outstruct )
}




#' @name ripmmarcBasisImage
#' @title Generate an antsImage from ripmmarc basis data
#' @description This function converts a vectorized image patch back into an
#' antsImage such that it may be displayed in its extrinsic dimensionality.
#' @param canonicalFrame canonical frame image generated by ripmmarc
#' @param patchBasisVector the basis vector to convert to image space
#' @param eps small value threshold to help generate mask from canonicalFrame
#' @return antsImage
#' @author Kandel BM, Avants BB
#' @examples
#'
#' img <- antsImageRead( getANTsRData( "r16" ) )
#' msk <- thresholdImage( img, quantile( img[ img > 0 ] )[1], max( img ) )
#' ripped <- ripmmarc( img, msk, patchRadius=3, patchSamples=2000, patchVarEx=5)
#' bimg = ripmmarcBasisImage( ripped$canonicalFrame, ripped$basisMat[4,] )
#'
#' @export ripmmarcBasisImage
ripmmarcBasisImage <- function( canonicalFrame, patchBasisVector, eps = 1.e-12)
{
newimg = canonicalFrame * 0
frameMask = thresholdImage( abs( canonicalFrame ), eps, Inf )
if ( sum( frameMask ) != length( patchBasisVector ) )
  stop("Size of mask does not appear to match length of basis vector" )
newimg[ frameMask == 1 ] = patchBasisVector
return( newimg )
}
