if (n <= 0)
stop("n must be positive")
n <- as.integer(n)
if (is.null(since)) {
since_date = NULL
}  else {
since_date = strsplit(since, " ")[[1]][1]
}
if (is.null(until)) {
until_date = NULL
}  else {
until_date = strsplit(until, " ")[[1]][1]
if (until_date == since_date) {
until_date = as.Date(since_date) + 1
}
}
if (!is.null(geocode)) {
geocheck = strsplit(geocode[[1]], ",")[[1]]
lat = as.numeric(geocheck[1])
lon = as.numeric(geocheck[2])
if ((lon > 180) || (lon < -180)) {
stop("Longitude need to be in range [180,-180].")
}
if ((lat > 90) || (lat < -90)) {
stop("Latitude need to be in range [90.0,-90.0].")
}
}
params <- buildCommonArgs(lang = lang, locale = locale, since = since_date,
until = until_date, geocode = geocode, since_id = sinceID,
max_id = maxID, result_type = resultType)
params[["q"]] <- searchString
rm( list = ls() )
library(twitteR)
api_file = "~/Dropbox/Twitter_API_Key.txt"
twitter = readLines(api_file)
setup_twitter_oauth(twitter[1], twitter[2], twitter[3], twitter[4])
searchString = "@kwbroman"
n = 25; lang = NULL; since = NULL; until = NULL;
locale = NULL; geocode = NULL; sinceID = NULL; maxID = NULL;
resultType = NULL; retryOnRateLimit = 120;
rm( list = ls() )
library(twitteR)
api_file = "~/Dropbox/Twitter_API_Key.txt"
twitter = readLines(api_file)
setup_twitter_oauth(twitter[1], twitter[2], twitter[3], twitter[4])
searchString = "@kwbroman"
user = "strictlystat"
n = 25; lang = NULL; since = NULL; until = NULL;
locale = NULL; geocode = NULL; sinceID = NULL; maxID = NULL;
resultType = NULL; retryOnRateLimit = 120;
if (nchar(searchString) > 1000) {
stop("searchString can only be up to 1000 characters")
}
if (n <= 0)
stop("n must be positive")
n <- as.integer(n)
if (is.null(since)) {
since_date = NULL
}  else {
since_date = strsplit(since, " ")[[1]][1]
}
if (is.null(until)) {
until_date = NULL
}  else {
until_date = strsplit(until, " ")[[1]][1]
if (until_date == since_date) {
until_date = as.Date(since_date) + 1
}
}
if (!is.null(geocode)) {
geocheck = strsplit(geocode[[1]], ",")[[1]]
lat = as.numeric(geocheck[1])
lon = as.numeric(geocheck[2])
if ((lon > 180) || (lon < -180)) {
stop("Longitude need to be in range [180,-180].")
}
if ((lat > 90) || (lat < -90)) {
stop("Latitude need to be in range [90.0,-90.0].")
}
}
params <- twitteR:::buildCommonArgs(lang = lang, locale = locale, since = since_date,
until = until_date, geocode = geocode, since_id = sinceID,
max_id = maxID, result_type = resultType)
params[["q"]] <- searchString
params[["include_entities"]] = TRUE
if (!is.null(user)){
uParams = twitteR:::parseUsers(user)
params[["user_id"]] = uParams[["user_id"]]
params[["screen_name"]] = uParams[["screen_name"]]
}
doRppAPICall
jsonList <- twitteR:::doRppAPICall("search/tweets", n, params = params,
retryOnRateLimit = retryOnRateLimit
)()
jsonList <- twitteR:::doRppAPICall("search/tweets", n, params = params,
retryOnRateLimit = retryOnRateLimit
)
statuses = import_statuses(jsonList)
datetimes = sapply(statuses, function(x) x$getCreated())
if (is.null(since)) {
since_statuses = seq_along(statuses)
} else {
since_statuses = which(datetimes >= as.numeric(as.POSIXct(since,
tz = "UTC")))
}
if (is.null(until)) {
until_statuses = seq_along(statuses)
} else {
until_statuses = which(datetimes <= as.numeric(as.POSIXct(until,
tz = "UTC")))
}
good_statuses = intersect(since_statuses, until_statuses)
good_statuses
statuses[good_statuses]
params
uParams
getSlots
statuses
?statuses
?status
rm( list = ls() )
library(twitteR)
api_file = "~/Dropbox/Twitter_API_Key.txt"
twitter = readLines(api_file)
setup_twitter_oauth(twitter[1], twitter[2], twitter[3], twitter[4])
##############################
# Get favorited tweets by a certain user
##############################
user = "strictlystat"
favs = favorites(user = user, n = 100)
find_user = "kwbroman"
sns = sapply(favs, `[[`, "screenName")
find_user_favs = favs[sns %in% find_user]
find_user = "kwbroman"
sns = sapply(favs, `[[`, "screenName")
find_user_favs = favs[sns %in% find_user]
find_user_favs
?mentions
mentions
ss = searchTwitter("@kwbroman -from:@strictlystat")
ss
ss = searchTwitter("@kwbroman+from:@strictlystat")
ss
ss = searchTwitter("@kwbroman+from:strictlystat")
ss
ss = searchTwitter("kwbroman+from:strictlystat")
ss
searchTwitter()
searchTwitter
ss = searchTwitter("@kwbroman+from:@strictlystat")
searchTwitter()
searchTwitter
searchTwitter()
searchTwitter
?searchTwitter
source('~/Dropbox/Twitter_Example.R')
ss
?searchTwitteR
library(swirl)
swirl()
y
bye()
library(dplyr)
mtcars
head(mtcars)
mtcars[ mtcars$gear == 4, ]
gear4 = filter(mtcars, gear == 4)
head(gear4)
?filter
library(BiocParallel)
?BiocParallel:::bplapply
browseVignettes("BiocParallel")
library(caret)
library(readr)
?read_csv
library(data.table)
?fread
library(ggvis)
browseVignettes("ggvis")
??ggvis
?ggvis
mtcars %>% ggvis(~mpg, ~wt)
mtcars %>%
ggvis(~mpg, ~wt) %>%
layer_points() %>%
layer_smooths()
library(manipulate)
help("manipulate")
manipulate(
plot(cars, xlim=c(x.min,x.max)),
x.min=slider(0,15),
x.max=slider(15,30))
manipulate(
plot(cars, xlim=c(x.min,x.max)),
x.min=slider(0,15),
x.max=slider(15,30))
.Platform
.Platform()
.Platform
.Platform$OS.type
source('~/Dropbox/ShinyApps/ShinyDesignOptimizer/Descriptions.R')
library(googleCite)
library(googleCite)
library(scholar)
ss = searchCite("Brian Caffo")
ss_cites = get_publications("Ff81yEQAAAAJ")
ss_cites = get_publications("Ff81yEQAAAAJ")
?get_publications
ss_cites = get_publications("Ff81yEQAAAAJ")
get_publications
head(ss)
ss_cites = get_publications("Ff81yEQAAAAJ")
install.packages("CITAN")
library(CITAN)
first_name = NULL
query = paste0("AUTHFIRST(", first_name, ")+AND+")
query
query = paste("AUTHFIRST(", first_name, ")+AND+")
query
first_name
query = ""
if (!is.null(first_name)){
query = paste0("AUTHFIRST(", first_name, ")+AND+")
}
query
query = paste0(query,
"AUTHLAST(", last_name, ")")
last_name = "Caffo"
query = ""
if (!is.null(first_name)){
query = paste0("AUTHFIRST(", first_name, ")+AND+")
}
query = paste0(query,
"AUTHLAST(", last_name, ")")
query
url = paste0(http, "?query=", query,
"&APIKey=", api_key)
xcr = cr = content(GET(url))
http = "http://api.elsevier.com/content/search/author" # Author API http
api_key
api_key = "24d178d5cce93c679eac25f08088cf70"
url = paste0(http, "?query=", query,
"&APIKey=", api_key)
xcr = cr = content(GET(url))
library(httr)
url = paste0(http, "?query=", query,
"&APIKey=", api_key)
xcr = cr = content(GET(url))
cr
rm(list=ls())
cases = list(
structure(list(weight = 1, mean_s1_trt = 0.125, mean_s2_trt = 0,
var_s1_trt = 0.1875, var_s1_con = 0.1875, var_s2_trt = 0.16,
var_s2_con = 0.16, mean_s1_con = 0, mean_s2_con = 0,
hard_mins = structure(list(Pow_H01 = 0.8, Pow_H02 = 0,
Pow_H0C = 0), .Names = c("Pow_H01", "Pow_H02", "Pow_H0C"
))),
.Names = c("weight", "mean_s1_trt", "mean_s2_trt",
"var_s1_trt", "var_s1_con", "var_s2_trt", "var_s2_con", "mean_s1_con",
"mean_s2_con", "hard_mins"))
)
library(designOptim)
library(gtools)
# stage1_feasible <- min_n_feasible(
min_n = 30;
max_n = 1600*1000;
step_n = 1;
p1= 0.33;
r1 = 0.5;
r2 = 1-r1;
showiter = TRUE;
FWER = 0.025;
cases=cases;
npoints_sqrt=25;
use_soft=FALSE;
# )
seq1 <- seq(0, FWER, by = FWER/npoints_sqrt)
seq1 <- seq1[designOptim:::orderByMids(order(seq1))]
alpha_1 = seq1[1]
case = cases[[1]]
maker = function(x){
full_case_args <- c(list(num_stages = 1, n_per_stage = x,
iter = 10000, p1 = p1, r1 = r1, r2 = r2, H01_eff_allocated = alpha_1,
H02_eff_allocated = alpha_2, H0C_eff_allocated = (FWER -
(alpha_1 + alpha_2))), H01_futility_boundaries = -Inf,
H02_futility_boundaries = -Inf, H0C_futility_boundaries = -Inf,
case)
}
lists = lapply(seq(min_n, max_n, by = step_n), maker)
rm(list=ls())
cases = list(
structure(list(weight = 1, mean_s1_trt = 0.125, mean_s2_trt = 0,
var_s1_trt = 0.1875, var_s1_con = 0.1875, var_s2_trt = 0.16,
var_s2_con = 0.16, mean_s1_con = 0, mean_s2_con = 0,
hard_mins = structure(list(Pow_H01 = 0.8, Pow_H02 = 0,
Pow_H0C = 0), .Names = c("Pow_H01", "Pow_H02", "Pow_H0C"
))),
.Names = c("weight", "mean_s1_trt", "mean_s2_trt",
"var_s1_trt", "var_s1_con", "var_s2_trt", "var_s2_con", "mean_s1_con",
"mean_s2_con", "hard_mins"))
)
library(designOptim)
library(gtools)
# stage1_feasible <- min_n_feasible(
min_n = 30;
max_n = 1600*1000;
step_n = 1;
p1= 0.33;
r1 = 0.5;
r2 = 1-r1;
showiter = TRUE;
FWER = 0.025;
cases=cases;
npoints_sqrt=25;
use_soft=FALSE;
# )
seq1 <- seq(0, FWER, by = FWER/npoints_sqrt)
seq1 <- seq1[designOptim:::orderByMids(order(seq1))]
alpha_1 = seq1[1]
case = cases[[1]]
seq2 <- seq1[seq1 <= FWER - alpha_1]
alpha_2 = seq2[1]
maker = function(x){
full_case_args <- c(list(num_stages = 1, n_per_stage = x,
iter = 10000, p1 = p1, r1 = r1, r2 = r2, H01_eff_allocated = alpha_1,
H02_eff_allocated = alpha_2, H0C_eff_allocated = (FWER -
(alpha_1 + alpha_2))), H01_futility_boundaries = -Inf,
H02_futility_boundaries = -Inf, H0C_futility_boundaries = -Inf,
case)
}
lists = lapply(seq(min_n, max_n, by = step_n), maker)
rm(list=ls())
cases = list(
structure(list(weight = 1, mean_s1_trt = 0.125, mean_s2_trt = 0,
var_s1_trt = 0.1875, var_s1_con = 0.1875, var_s2_trt = 0.16,
var_s2_con = 0.16, mean_s1_con = 0, mean_s2_con = 0,
hard_mins = structure(list(Pow_H01 = 0.8, Pow_H02 = 0,
Pow_H0C = 0), .Names = c("Pow_H01", "Pow_H02", "Pow_H0C"
))),
.Names = c("weight", "mean_s1_trt", "mean_s2_trt",
"var_s1_trt", "var_s1_con", "var_s2_trt", "var_s2_con", "mean_s1_con",
"mean_s2_con", "hard_mins"))
)
library(designOptim)
library(gtools)
# stage1_feasible <- min_n_feasible(
min_n = 30;
max_n = 1600*1000;
step_n = 10;
p1= 0.33;
r1 = 0.5;
r2 = 1-r1;
showiter = TRUE;
FWER = 0.025;
cases=cases;
npoints_sqrt=25;
use_soft=FALSE;
# )
seq1 <- seq(0, FWER, by = FWER/npoints_sqrt)
seq1 <- seq1[designOptim:::orderByMids(order(seq1))]
alpha_1 = seq1[1]
case = cases[[1]]
seq2 <- seq1[seq1 <= FWER - alpha_1]
alpha_2 = seq2[1]
maker = function(x){
full_case_args <- c(list(num_stages = 1, n_per_stage = x,
iter = 10000, p1 = p1, r1 = r1, r2 = r2, H01_eff_allocated = alpha_1,
H02_eff_allocated = alpha_2, H0C_eff_allocated = (FWER -
(alpha_1 + alpha_2))), H01_futility_boundaries = -Inf,
H02_futility_boundaries = -Inf, H0C_futility_boundaries = -Inf,
case)
}
lists = lapply(seq(min_n, max_n, by = step_n), maker)
length(lists)
case$performance <- do.call(buildTrial, lists[[1]])$performance
case$performance
buildTrial()
buildTrial
getEffBounds
library(plyr)
rm(list=ls())
cases = list(
structure(list(weight = 1, mean_s1_trt = 0.125, mean_s2_trt = 0,
var_s1_trt = 0.1875, var_s1_con = 0.1875, var_s2_trt = 0.16,
var_s2_con = 0.16, mean_s1_con = 0, mean_s2_con = 0,
hard_mins = structure(list(Pow_H01 = 0.8, Pow_H02 = 0,
Pow_H0C = 0), .Names = c("Pow_H01", "Pow_H02", "Pow_H0C"
))),
.Names = c("weight", "mean_s1_trt", "mean_s2_trt",
"var_s1_trt", "var_s1_con", "var_s2_trt", "var_s2_con", "mean_s1_con",
"mean_s2_con", "hard_mins"))
)
library(designOptim)
library(gtools)
# stage1_feasible <- min_n_feasible(
min_n = 30;
max_n = 1600*1000;
step_n = 10;
p1= 0.33;
r1 = 0.5;
r2 = 1-r1;
showiter = TRUE;
FWER = 0.025;
cases=cases;
npoints_sqrt=25;
use_soft=FALSE;
# )
seq1 <- seq(0, FWER, by = FWER/npoints_sqrt)
seq1 <- seq1[designOptim:::orderByMids(order(seq1))]
alpha_1 = seq1[1]
case = cases[[1]]
seq2 <- seq1[seq1 <= FWER - alpha_1]
alpha_2 = seq2[1]
maker = function(x){
full_case_args <- c(list(num_stages = 1, n_per_stage = x,
iter = 10000, p1 = p1, r1 = r1, r2 = r2, H01_eff_allocated = alpha_1,
H02_eff_allocated = alpha_2, H0C_eff_allocated = (FWER -
(alpha_1 + alpha_2))), H01_futility_boundaries = -Inf,
H02_futility_boundaries = -Inf, H0C_futility_boundaries = -Inf,
case)
}
lists = lapply(seq(min_n, max_n, by = step_n), maker)
case$performance <- laply(lists, function(r){
do.call(buildTrial, r)$performance
}, .progress = "text")
rm(list=ls())
cases = list(
structure(list(weight = 1, mean_s1_trt = 0.125, mean_s2_trt = 0,
var_s1_trt = 0.1875, var_s1_con = 0.1875, var_s2_trt = 0.16,
var_s2_con = 0.16, mean_s1_con = 0, mean_s2_con = 0,
hard_mins = structure(list(Pow_H01 = 0.8, Pow_H02 = 0,
Pow_H0C = 0), .Names = c("Pow_H01", "Pow_H02", "Pow_H0C"
))),
.Names = c("weight", "mean_s1_trt", "mean_s2_trt",
"var_s1_trt", "var_s1_con", "var_s2_trt", "var_s2_con", "mean_s1_con",
"mean_s2_con", "hard_mins"))
)
library(designOptim)
library(gtools)
# stage1_feasible <- min_n_feasible(
min_n = 30;
max_n = 1600*1000;
step_n = 10;
p1= 0.33;
r1 = 0.5;
r2 = 1-r1;
showiter = TRUE;
FWER = 0.025;
cases=cases;
npoints_sqrt=25;
use_soft=FALSE;
# )
seq1 <- seq(0, FWER, by = FWER/npoints_sqrt)
seq1 <- seq1[designOptim:::orderByMids(order(seq1))]
alpha_1 = seq1[1]
case = cases[[1]]
seq2 <- seq1[seq1 <= FWER - alpha_1]
alpha_2 = seq2[1]
maker = function(x){
full_case_args <- c(list(num_stages = 1, n_per_stage = x,
iter = 10000, p1 = p1, r1 = r1, r2 = r2, H01_eff_allocated = alpha_1,
H02_eff_allocated = alpha_2, H0C_eff_allocated = (FWER -
(alpha_1 + alpha_2))), H01_futility_boundaries = -Inf,
H02_futility_boundaries = -Inf, H0C_futility_boundaries = -Inf,
case)
}
lists = lapply(seq(min_n, max_n, by = step_n), maker)
perf <- laply(lists, function(r){
do.call(buildTrial, r)$performance
}, .progress = "text")
x <- 5 -> y
x
y
I <- 0 -> l
I
l
q('no')
library(oro.nifti)
?orthographic
image
oro.nifti:::image.nifti()
oro.nifti:::image.nifti
citation("randomForest")
dropEmptyImageDimensions
library(fslr)
dropEmptyImageDimensions
library(ANTsR)
ANTsR::imageMath
ANTsR:::imageMath
setwd("~/Dropbox/Packages/ANTsR/R")
img = readnii("~/Desktop/scratch/VSD.Brain.XX.O.MR_Flair.70614_SyN.nii.gz")
library(fslr)
library(extrantsr)
img = check_ants(img)
img = readnii("~/Desktop/scratch/VSD.Brain.XX.O.MR_Flair.70614_SyN.nii.gz")
img = check_ants(img)
dim<-img@dimension
lowerThresh = min(img)
# }
# if (is.null(upperThresh)){
upperThresh = max(img)
operation = "Canny"
args = list()
args =  list(img, operation, 1, lowerThresh upperThresh, ...)
args =  list(img, operation, 1, lowerThresh, upperThresh)
args
retval = .Call("iMathInterface", args, PACKAGE="ANTsR")
retval
?iMath()
iMath(retval, "GetOperationsFull")
source('~/Downloads/papayaWidget/R/papayaW.R')
papayaW()
