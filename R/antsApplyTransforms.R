#' Apply transforms to images.
#'
#' Apply a transform list to map an image from one domain to another. In image
#' registration, one computes mappings between (usually) pairs of images.
#' These transforms are often a sequence of increasingly complex maps, e.g.
#' from translation, to rigid, to affine to deformation.  The list of such
#' transforms is passed to this function to interpolate one image domain
#' into the next image domain, as below.  The order matters strongly and the
#' user is advised to familiarize with the standards established in examples.
#'
#' @param fixed fixed image defining domain into which the moving image is
#' transformed.
#' @param moving moving image to be mapped to fixed space.
#' @param transformlist character vector of transforms generated by antsRegistration where
#' each transform is a filename.
#' @param interpolator Choice of interpolator.  One of: Linear,
#' NearestNeighbor, MultiLabel, CosineWindowedSinc, WelchWindowedSinc,
#' HammingWindowedSinc, LanczosWindowedSinc, Gaussian, or BSpline.
#' other interpolator available in antsApplyTransforms.
#' @param imagetype choose 0/1/2/3 mapping to scalar/vector/tensor/time-series
#' @param whichtoinvert optional list of booleans, same length as transforms.
#' whichtoinvert[i] is TRUE if transformlist[i] is a matrix, and the matrix should
#' be inverted. If transformlist[i] is a warp field, whichtoinvert[i] must be FALSE.
#'
#' If the transform list is a matrix followed by a warp field, whichtoinvert
#' defaults to c(TRUE,FALSE). Otherwise it defaults to rep(FALSE, length(transformlist)).
#' @param verbose print command and run verbose application of transform.
#' @param ... extra parameters
#' @return an antsImage is output. 1 -- Failure
#' @author Shrinidhi KL, Avants BB
#' @examples
#'
#' # will give the full form of help
#' antsApplyTransforms("-h")
#' # see antsRegistration
#' # example 1 - simplified
#' fixed <- antsImageRead( getANTsRData("r16") ,2)
#' moving <- antsImageRead( getANTsRData("r64") ,2)
#' fixed <- resampleImage(fixed,c(64,64),1,0)
#' moving <- resampleImage(moving,c(64,64),1,0)
#' mytx <- antsRegistration(fixed=fixed , moving=moving ,
#'   typeofTransform = c("SyN") )
#' mywarpedimage <- antsApplyTransforms( fixed=fixed,moving=moving,
#'   transformlist=mytx$fwdtransforms )
#' mywarpedimage <- antsApplyTransforms( fixed=moving,moving=fixed,
#'   transformlist=mytx$invtransforms )
#' # full access via listing the inputs in standard ANTs format
#'
#' @seealso \code{\link{antsRegistration}}
#' @export antsApplyTransforms
antsApplyTransforms <- function(
  fixed,
  moving,
  transformlist = "",
  interpolator = "Linear",
  imagetype = 0, whichtoinvert = NA, verbose = FALSE, ... ) {
  if (missing(fixed) | missing(moving) | missing(transformlist)) {
    cat(" warpedimg<-antsApplyTransforms( fixed=img1 , moving=img2 , transformlist=c(\"my0GenericAffine.mat\",\"my1Warp.nii.gz\") ) ")
    cat("\n\n")
    cat("For full mode: use standard ants call as in antsApplyTransforms full mode ... \n\n")
    cat(" antsApplyTransforms(\"-d\",\"2\",\"-i\",\"r64slice.nii.gz\",\"-o\",\"temp.nii.gz\",\"-r\",\"r16slice.nii.gz\",\"-t\",\"./Z0GenericAffine.mat\") \n")
    cat("for full help: \n")
    cat("use .Call( \"antsApplyTransforms\", .int_antsProcessArguments( c(list(\"--help\")) ), PACKAGE=\"ANTsR\" );\n\n")
    return(1)
  }
  args <- list(fixed, moving, transformlist, interpolator, ...)
  if (!is.character(fixed)) {
    if (fixed@class[[1]] == "antsImage" & moving@class[[1]] == "antsImage") {
      for (i in 1:length(transformlist)) {
        if (!file.exists(transformlist[i])) {
          stop(paste("Transform ", transformlist[i], " does not exist.", sep = ""))
        }
      }
      inpixeltype <- fixed@pixeltype
      warpedmovout <- antsImageClone(moving)
      f <- fixed
      m <- moving
      wmo <- warpedmovout
      mytx <- list()
      # If whichtoinvert is NA, then attempt to guess the right thing to do
      #
      # If the transform list is (affine.mat, warp), whichtoinvert = c("T", "F")
      #
      # else whichtoinvert = rep("F", length(transformlist))
      if (all(is.na(whichtoinvert))) {
        if ( length(transformlist) == 2 & grepl("\\.mat$", transformlist[1]) & !(grepl("\\.mat$", transformlist[2])) ) {
          whichtoinvert <- c(T, F)
        }
        else {
          whichtoinvert <- rep(F, length(transformlist))
        }
      }
      if (length(whichtoinvert) != length(transformlist)) {
        stop("Transform list and inversion list must be the same length")
      }
      for (i in c(1:length(transformlist))) {
        ismat <- FALSE
        if (grepl("\\.mat$", transformlist[i])) {
          ismat <- TRUE
        }
        if (whichtoinvert[i] && !(ismat) ) {
          # Can't invert a warp field, user should pass inverseWarp directly. Something wrong
          stop(paste("Cannot invert transform " , i , " ( " , transformlist[i], " ), because it is not a matrix. ", sep = ""))
        }
        if (whichtoinvert[i]) {
          mytx <- list(mytx, "-t", paste("[", transformlist[i], ",1]",
                                         sep = ""))
        }
        else {
          mytx <- list(mytx, "-t", transformlist[i])
        }

      }
      args <- list(d = fixed@dimension, i = m, o = wmo, r = f, n = interpolator,
                   unlist(mytx))
      myargs <- .int_antsProcessArguments(c(args))
      for (jj in c(1:length(myargs))) {
        if (!is.na(myargs[jj])) {
          if (myargs[jj] == "-") {
            myargs2 <- rep(NA, (length(myargs) - 1))
            myargs2[1:(jj - 1)] <- myargs[1:(jj - 1)]
            myargs2[jj:(length(myargs) - 1)] <- myargs[(jj + 1):(length(myargs))]
            myargs <- myargs2
          }
        }
      }
      myverb = as.numeric( verbose )
      if ( verbose ) print( myargs )
      .Call("antsApplyTransforms",
        c(myargs, "-z", 1, "-v", myverb, "--float", 1, "-e", imagetype),
        PACKAGE = "ANTsR")
      return(antsImageClone(warpedmovout, inpixeltype))
    }
    # Get here if fixed, moving, transformlist are not missing, fixed is not of type character,
    # and fixed and moving are not both of type antsImage
    return(1)
  }
  # if ( Sys.info()['sysname'] == 'XXX' ) { mycmd<-.antsrParseListToString( c(args)
  # ) system( paste('antsApplyTransforms ', mycmd$mystr ) ) return( antsImageRead(
  # mycmd$outimg, as.numeric(mycmd$outdim) ) ) }
  .Call("antsApplyTransforms",
    .int_antsProcessArguments(
    c( args, "-z", 1, "--float", 1, "-e", imagetype)), PACKAGE = "ANTsR")
}


.antsrParseListToString <- function(mylist, outimg = NA, outdim = NA) {
  mystr <- ""
  len <- length(mylist)
  outimg <- ""
  outdim <- 11
  for (x in 1:len) {
    if (class(mylist[[x]])[1] == "antsImage") {
      tfn <- paste(tempdir(), "img", x, ".nii.gz", sep = "")
      antsImageWrite(mylist[[x]], tfn)
      mystr <- paste(mystr, tfn)
      outdim <- mylist[[x]]@dimension
      if (typeof(mylist[[x - 1]]) == "character") {
        if (mylist[[x - 1]] == "-o")
          outimg <- tfn
      }
      if (typeof(mylist[[x - 1]]) != "S4")
        if (mylist[[x - 1]] == "-o")
          outimg <- tfn
    } else mystr <- paste(mystr, toString(mylist[[x]]))
  }
  mystr <- sub(",", " ", mystr)
  mystr <- sub(" - ", " ", mystr)
  mystr <- sub("-t,", "-t ", mystr)
  mystr <- sub(", ", " ", mystr)
  return(list(mystr = mystr, outimg = outimg, outdim = outdim))
}

..antsrParseListToString2 <- function(mylist, outimg = NA, outdim = NA) {
  mystr <- ""
  outimg <- ""
  outdim <- 11
  len <- length(mylist)
  for (x in 1:len) {
    mystr <- paste(mystr, " -", names(mylist)[x], " ", sep = "")
    if (class(mylist[[x]])[1] == "antsImage") {
      tfn <- paste(tempdir(), "img", x, ".nii.gz", sep = "")
      antsImageWrite(mylist[[x]], tfn)
      mystr <- paste(mystr, tfn)
      outdim <- mylist[[x]]@dimension
      if (names(mylist)[x] == "o")
        outimg <- tfn
    } else mystr <- paste(mystr, toString(mylist[[x]]))
  }
  mystr <- sub(",", " ", mystr)
  mystr <- sub(" - ", " ", mystr)
  mystr <- sub("-t,", "-t ", mystr)
  mystr <- sub(", ", " ", mystr)
  return(list(mystr = mystr, outimg = outimg, outdim = outdim))
}
