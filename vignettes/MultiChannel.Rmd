---
title: "Multichannel image proccessing"
author: "Jeffrey T. Duda"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: REFERENCES.bib
vignette: >
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteIndexEntry{Multichannel images}
    \usepackage[utf8]{inputenc}
---

```{r, echo = FALSE, message = FALSE, include = FALSE}
library( knitr )
knitr::opts_chunk$set(collapse = T, comment = "#>")
library(ANTsR)
library(ggplot2)
library(grid)
```

## Overview
This document provides some examples illustrating how [ANTsR](https://github.com/stnava/ANTsR)
may be used to work with multihchannel images, such as rgb (i.e. color) data. This
is still an extremely new feature and much of ANTsR does not support this image type.
Examples will be added to this document as new functionality is implemented.

## Basics
Because ANTsR relies upon [ITK](http://www.itk.org) for image IO, multichannel support is inherently built in. In
this example a file is read in, and each channel is smoothed independently.

```{r plotColor,message=FALSE,warnings=FALSE, fig.width=7, fig.height=5, echo=FALSE}
# How to plot a 2D color image
plotColor <- function(imgList) {
  rgbList = lapply( imgList, function(x) { apply(t(as.matrix(x)),2,rev) /255 })
  col <- rgb(rgbList[[1]], rgbList[[2]], rgbList[[3]])

  d = dim(rgbList[[1]])

  x = rep(1:d[2],each=d[1])
  y = rep(1:d[2], d[1])
  pts = antsTransformIndexToPhysicalPoint( imgList[[1]], cbind(x,y) )

  dat = data.frame(x=pts[,1], y=pts[,2], col=col)
  x1 = min(pts[,1])
  x2 = max(pts[,1])
  y1 = min(pts[,2])
  y2 = max(pts[,2])

  g = ggplot(dat, aes(x=x, y=y, fill=col)) + geom_raster(hjust=0, vjust=0, alpha=1) + theme(legend.position="none", aspect.ratio=1,text=element_blank(),axis.ticks=element_blank(), panel.grid=element_blank() ) + scale_fill_manual(values=as.character(levels(factor(col))) ) + coord_cartesian(xlim=c(x1,x2), ylim=c(y1,y2))
  print(g)

  #dim(col) <- dim(imgList[[1]])
  #grid.raster(col, interpolate=FALSE)
}
```

```{r io,message=FALSE,warnings=FALSE, fig.width=7, fig.height=5, echo=TRUE}
# Read in and display header info
img = antsImageRead( getANTsRData("decslice"))
img

# Convert to list of scalar images
iList = splitChannels(img)
plotColor(iList)
```

The `lapply` function provides a convenient way to process all channels

```{r lapply,message=FALSE,warnings=FALSE, fig.width=7, fig.height=5, echo=TRUE}
sList = lapply( iList, function(x) { smoothImage(x, 1.5) } )
plotColor(sList)

# Merge back into multichannel image
simg = mergeChannels(sList)

# Write to file
# antsImageWrite(simg, "smoothslice.nii.gz")
```

ggplot(dat, aes(x=x, y=y, fill=col)) + geom_raster(hjust=0, vjust=0) + theme(legend.position="none", aspect.ratio=1 ) + scale_fill_manual(values=as.character(levels(factor(rgb))) )



## References
