---
title: "%doMath% (common mathematical operations inside ANTsR)"
author: "Brian B. Avants, Arman Eshaghi"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteIndexEntry{Transformations and statistical representations for images in R}
    \usepackage[utf8]{inputenc}
---

```{r, echo = FALSE, message = FALSE}
knitr::opts <- chunk$set(collapse = T, comment = "#>")
library(ANTsR)
```

## Basic operations

`%doMath%` is a versatile tool that wraps `ImageMath` from ANTs software. For basic 
arithmetics (e.g., add, subtract), while it's possible to use `%doMath%, usually it 
is easier to use `antsImage` class capabilities. `%doMath` is an infix function that
provides easy combination of several mathematical operations with R's functional
programming style.

  * Basic arithmetics with `antsImageClass` is easier, and is similar to 
  array operations in R:

    ```{r}
    fi  <- antsImageRead(getANTsRData("r16"), 2)
    sumfi <- fi + fi
    mulfi <- fi * 2
    #logarithm of image where non-zero
    logfi <- log(fi[fi>0])
    expfi <- exp(fi[fi>0)
    divfi <- sumfi / mulfi
    ```

##Dilation or erosion of masks and images

The typical rule for dilation and erosion of images in ANTsR is minimum 
for erosion and maximum for dilation (ITK rules).

  * Grayscale dilation of an image (compare it with binary dilation below):
  
    ```{r}
    #dilating by a radius of 3 voxels
    GDdilated <- fi %doMath% "GD 3" 
    #to see what dilation has done
    invisible(plot(GDdilated))
    #to see the difference a dilation can make
    invisible(plot(GDdilated - fi))
    ```

  * Grayscale erosion of an image (compare it with binary erosion below).

    ```{r}
    erosion <- fi %doMath% "GE 3"
    invisible(plot(erosion))

    ```

  * Morphological dilation works on binary images, where it makes white 
  regions bigger:

    ```{r}
    mask <- getMask(fi)
    MD <- mask %doMath% "MD 3"
    #to see the difference it made
    invisible(plot(MD - mask))
    ```

  * Morphological erosion makes white regions of a binary mask smaller.

    ```{r}
    ME <- mask %doMath% "ME 3"
    invisible(plot(ME))
    ```

##Opening and closing image filters

  * Morphological closing of a binary image: operation `MC` fill holes with the 
    provided radius parameter, for example:

      ```{r}
      newMask <- mask %doMath% "MC 4"
      invisible(plot(newMask))
      ```

  * Morphological opening of a binary image: removes small structures at the boundary 
    or interior of an image. Syntax is similar to the previous procedure with the operation
    `MO`.


##Padding or cropping an image 

`PadImage` is a function to add/remove voxels to/from images.

* Positive numbers will pad image in each direction. So for example using 2
  will increase an image with 256 voxels to 260.
  
    ```{r}
    padded <- fi %doMath% "PadImage 2"
    #compare padded image dimensions with the original dimensions
    dim(fi)
    dim(padded)
    ```

  * Negative numbers will crop the image in each direciton. For example using -2
  will convert a 2-dimensional image with 256 voxels in X and Y direction to 
  252 voxels in each dimension.

    ```{r}
    cropped <- fi %doMath "PadImage -2"
    #compare cropped image with the original one
    dim(fi)
    dim(cropped)
    ```

##Distance map
  
  * `MaurerDistance` calculates the Euclidean distance transform of a binary
  image in time linear with total number of voxels. It assumes that inside 
  the binary image has negative distance, while outside of the binary mask
  has positve distance. Distance maps could be used for example, in shape 
  analysis, skletonizing or path finding.

    ```{r}
    distanceMap <- mask %doMath% "MaurerDistance"
    invisible(plot(distanceMap))
    ```

 *  `D` implements ITK's `DanielssonDistanceMap`. It calculates the Euclidean
   distance map, which shows at each voxel the shortest distance to the nearest
   voxel in the background (assuming that the input is a binary image).
    
    ```{r}
    distanceMap <- mask %doMath% "D"
    invisible(plot(distanceMap))
    ```

##Denoising with anisotropic diffusion

To reduce noise without changing important parts of an image in computer vision, Perona-Malik is a
promising method. Perona-Malik method to reduce noise with anisotropic diffusion is accessible 
via `PeronaMalik` operation in `iMath`. It requires two parameters: 1) number of iterations, and 
2) conductance.

  ```{r}
  denoised <- fi %doMath% "PeronaMalik 10 0.5"
  invisible(plot(denoised))
  #to see what the filter has removed
  invisible(plot(fi - denoised)) 
  ```

##Magnitude of gradient computation

`Grad` operation in `iMath` calculates the gradient of the magnitude of an image by convolution
with the first derivative of a Gaussian. Required parameters are: 1) sigma, and 2) normalize 
output (0 or 1, boolean).

  ```{r}
  grad <- fi %doMath% "Grad 1"
  invisible(plot(grad))
  ```

##Laplacian of Gaussian of an image

`Laplacian` operation calculates the the Laplacian of Gaussian of an image by convolving with
the second derivative of a Gaussian. `sigma` and `normalize` (0 or 1, boolean) are two required 
parameters.

  ```{r}
  laplacianImage <- fi %doMath% "Laplacian 1 1"
  invisible(plot(laplacianImage))
  ```

##Sequential operations on images

Usually it is easier to perform sequential procedures, starting from an image without any need
to save temporary files. Functional programming style allows this elegantly:

  ```{r}
  #we need to normalize an image and then calculate the Laplacian, and 
  #finaly look at the difference in one line of code
  invisible(plot(fi %doMath% "Normalize" %doMath% "Laplacian 1 1" - (fi %doMath% "Normalize" ) * -1)) 
  ```

##Other operations

| Operation     | Example                   | Description                |
| ------------- |:-------------------------:| --------------------------:|
| FillHoles     |`img %doMath% "FillHoles"`| Fills holes in binary object|
| GetLargestComponent |`img %doMath% "GetLargestComponent"|Returns largest portion of binary object|
| Neg | `img %doMath% "Neg"`|Creates image negative|
|Normalize| `img %doMath% "Normalize"` |Creates image negative|
|TruncateImageIntensity| `img %doMath% "TruncateImageIntensity 0.05 0.95"`|Trims intensities by quantiles|
|Sharpen| `img %doMath% "Sharpen"` | Makes edges sharper|
