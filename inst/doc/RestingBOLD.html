<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Jeffrey T. Duda, Brian B. Avants" />

<meta name="date" content="2017-05-25" />

<title>Resting BOLD (basic analyses using ANTsR)</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Resting BOLD (basic analyses using ANTsR)</h1>
<h4 class="author"><em>Jeffrey T. Duda, Brian B. Avants</em></h4>
<h4 class="date"><em>2017-05-25</em></h4>



<div id="overview" class="section level2">
<h2>Overview</h2>
<p>This document provides some examples illustrating how <a href="https://github.com/stnava/ANTsR">ANTsR</a> may be used to analyze resting state BOLD fMRI data using established methodology. The focus is on processing the BOLD signal, here we start with the the following data</p>
<ul>
<li><p>A BOLD fMRI time-series image</p></li>
<li><p>A brain mask image</p></li>
<li><p>A tissue-segmentation that identifies (at least): CSF, gray matter, white matter</p></li>
<li><p>A set of labels identifying anatomical regions of interest (the network to analyze)</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fdthresh =<span class="st"> </span><span class="fl">0.1</span> <span class="co"># threshold for throwing out bad data, typically between 0.1 and 0.5</span>
<span class="co"># based on ACT output or sample data</span>
id =<span class="st"> &quot;BAvants&quot;</span>
pre =<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;~/rsfTest/&quot;</span>,id,<span class="st">&quot;/&quot;</span>,<span class="dt">sep=</span><span class="st">''</span>)
fn =<span class="st"> </span><span class="kw">path.expand</span>( <span class="kw">paste</span>( pre, <span class="st">&quot;rsfMRI0/&quot;</span>,id,<span class="st">&quot;_rsfMRI0.nii.gz&quot;</span>, <span class="dt">sep=</span><span class="st">''</span> ) )
testData =<span class="st"> </span><span class="dv">1</span>
<span class="cf">if</span> ( <span class="kw">file.exists</span>( fn ) )
  {
  fdthresh =<span class="st"> </span><span class="fl">0.2</span> <span class="co"># threshold for throwing out bad data, typically between 0.1 and 0.5</span>
  testData =<span class="st"> </span><span class="dv">3</span>
  img  =<span class="st"> </span><span class="kw">antsImageRead</span>( fn  )
  meanbold =<span class="st"> </span><span class="kw">getAverageOfTimeSeries</span>( img )
  mask =<span class="st"> </span><span class="kw">getMask</span>( meanbold )
  sfn =<span class="st"> </span><span class="kw">path.expand</span>( <span class="kw">paste</span>( pre, <span class="st">&quot;/act/&quot;</span>, id,<span class="st">&quot;_STRUCTURAL_BrainSegmentation.nii.gz&quot;</span>, <span class="dt">sep=</span><span class="st">''</span> ) )
  seg =<span class="st"> </span><span class="kw">antsImageRead</span>( sfn   )
  t1fn =<span class="st"> </span><span class="kw">path.expand</span>( <span class="kw">paste</span>( pre, <span class="st">&quot;/act/&quot;</span>, id,<span class="st">&quot;_STRUCTURAL_BrainSegmentation0N4.nii.gz&quot;</span>, <span class="dt">sep=</span><span class="st">''</span> ) )
  t1 =<span class="st"> </span><span class="kw">antsImageRead</span>( t1fn   )
  } <span class="cf">else</span> { <span class="co"># use sample data</span>
  img =<span class="st"> </span><span class="kw">antsImageRead</span>(<span class="kw">getANTsRData</span>(<span class="st">&quot;rsbold&quot;</span>))
  meanbold =<span class="st"> </span><span class="kw">getAverageOfTimeSeries</span>( img )
  mask =<span class="st"> </span><span class="kw">antsImageRead</span>(<span class="kw">getANTsRData</span>(<span class="st">&quot;rsboldmask&quot;</span>))
  seg =<span class="st"> </span><span class="kw">antsImageRead</span>(<span class="kw">getANTsRData</span>(<span class="st">&quot;rsboldseg&quot;</span>))
  t1 =<span class="st"> </span><span class="kw">antsImageClone</span>( seg )
  t1[ t1 <span class="op">&gt;</span><span class="st"> </span><span class="dv">3</span> ] =<span class="st"> </span><span class="dv">2</span>
  }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">t1brain =<span class="st"> </span>t1 <span class="op">*</span><span class="st"> </span><span class="kw">thresholdImage</span>( seg, <span class="dv">1</span>, <span class="dv">6</span> )
<span class="cf">if</span> ( <span class="op">!</span><span class="st"> </span><span class="kw">exists</span>(<span class="st">&quot;boldmap&quot;</span>) )
  boldmap =<span class="st"> </span><span class="kw">antsRegistration</span>( meanbold, t1brain, <span class="dt">typeofTransform=</span><span class="st">'SyNBoldAff'</span> )
<span class="cf">if</span> ( <span class="op">!</span><span class="st"> </span><span class="kw">exists</span>(<span class="st">&quot;mnimap&quot;</span>) )
  {
  mni =<span class="st"> </span><span class="kw">antsImageRead</span>( <span class="kw">getANTsRData</span>( <span class="st">&quot;mni&quot;</span> ) )
  mnimap =<span class="st"> </span><span class="kw">antsRegistration</span>( t1brain, mni, <span class="dt">typeofTransform=</span><span class="st">'SyN'</span> )
  }
mni2boldmaps =<span class="st"> </span><span class="kw">c</span>( boldmap<span class="op">$</span>fwdtransforms, mnimap<span class="op">$</span>fwdtransforms )
mni2boldmapsInv =<span class="st"> </span><span class="kw">c</span>(  mnimap<span class="op">$</span>invtransforms , boldmap<span class="op">$</span>invtransforms )
mni2bold =<span class="st"> </span><span class="kw">antsApplyTransforms</span>( meanbold, mni, mni2boldmaps )
seg2bold =<span class="st"> </span><span class="kw">antsApplyTransforms</span>( meanbold, seg, boldmap<span class="op">$</span>fwdtransforms, <span class="dt">interpolator =</span> <span class="st">&quot;NearestNeighbor&quot;</span> )
<span class="kw">plot</span>( meanbold , boldmap<span class="op">$</span>warpedmovout <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">iMath</span>(<span class="st">&quot;Canny&quot;</span>, <span class="dv">10</span>, <span class="dv">1</span>, <span class="dv">1</span>) )
<span class="kw">plot</span>( meanbold , mni2bold <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">iMath</span>(<span class="st">&quot;Canny&quot;</span>, <span class="dv">10</span>, <span class="dv">1</span>, <span class="dv">1</span>) )
<span class="kw">plot</span>( meanbold , <span class="kw">maskImage</span>( seg2bold, seg2bold, <span class="dv">2</span> ) )</code></pre></div>
<p>Obtaining these for your own data set is a non-trivial matter, but will be the topic of a future document as the process is the same for both resting and task-based BOLD.</p>
<p>The processing here is largely based upon a recent review of methods for dealing with motion in resting fMRI <span class="citation">(Power et al. 2014)</span>.</p>
<p>The Preprocessing section includes methods used for processing fMRI for a variety of purposes. This is followed by a section on Connectivity processing that includes steps specific to the processing of resting state data. Finally, a section on building graphs and calculating graph metrics is presented.</p>
</div>
<div id="preprocessing" class="section level2">
<h2>Preprocessing</h2>
<p>One step that is omitted here is slice timing correction as this can vary greatly between acquisition sequences. The included steps are:</p>
<ul>
<li><p>Removal of initial time points that occur before magnetization steady state is reached</p></li>
<li><p>Rigid registration of time points to correct for subject head motion</p></li>
<li><p>Plotting of motion parameters for inspection</p></li>
<li><p>Identification of “bad” time points for exclusion</p></li>
</ul>
<div id="steady-state" class="section level3">
<h3>Steady-state</h3>
<p>The first step is the removal of pre steady state time points. It is typical to exclude any data obtained during the first 10 seconds as shown below. The choice of 10s is based on an informal review of current literature of 3T human data <span class="citation">(Power et al. 2012)</span>. For other applications, be sure to check the relevant literature.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Find first steady state timepoint</span>
tr =<span class="st"> </span><span class="kw">antsGetSpacing</span>(img)[<span class="dv">4</span>]
steady =<span class="st"> </span><span class="kw">floor</span>(<span class="fl">10.0</span> <span class="op">/</span><span class="st"> </span>tr) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>

<span class="co"># Global signal before cropping (save for visualization)</span>
origmean =<span class="st"> </span><span class="kw">apply.antsImage</span>(img, <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), mean)
fullmean =<span class="st"> </span><span class="kw">rowMeans</span>(<span class="kw">timeseries2matrix</span>(img, mask))
allTimes =<span class="st"> </span><span class="kw">dim</span>(img)[<span class="dv">4</span>]

<span class="co"># Eliminate non steady-state timepoints</span>
img =<span class="st"> </span><span class="kw">cropIndices</span>(img, <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,steady), <span class="kw">dim</span>(img) )</code></pre></div>
<p>In the plot below, mean global signal in the brain is plotted with a red box indicating the points at which the system has non yet reached the steady state. Data in this range are discarded.</p>
<p>The temporal mean of the original time series data:</p>
</div>
<div id="motion-correction" class="section level3">
<h3>Motion correction</h3>
<p>To correct for rigid body motion that occurs during acquisition:</p>
<ul>
<li><p>Find the mean volume of all time points. This is done with <code>apply.antsImage</code> which is an extension of the <code>R</code> method <code>apply</code> with additional functionality to maintain image header info integrity.</p></li>
<li><p>Align all time-points to the mean. This is accomplished with <code>antsMotionCalculation</code>, the <code>fixed</code> parameter is used to set the reference image to which all time-points are aligned and the <code>txtype</code> parameter indicates the type of transform to be estimated. The default for <code>txtype</code> is “Affine”, but for this type of analyses it is typical to use “Rigid”.</p></li>
<li><p>To help ensure an accurate fit, 3 iterations of the above steps are used</p></li>
<li><p>Examine motion correction parameters for quality control.</p></li>
<li><p>Identify “bad” time points for removal</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">if</span> ( <span class="op">!</span><span class="st"> </span><span class="kw">exists</span>(<span class="st">&quot;moco&quot;</span>) )
  {
  meanbold &lt;-<span class="st"> </span><span class="kw">apply.antsImage</span>(img, <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), mean)
  <span class="cf">for</span> ( i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>testData )
    {
    moco &lt;-<span class="st"> </span><span class="kw">antsMotionCalculation</span>( img, <span class="dt">fixed=</span>meanbold, <span class="dt">txtype=</span><span class="st">&quot;Rigid&quot;</span> )
    meanbold =<span class="st"> </span><span class="kw">apply.antsImage</span>( moco<span class="op">$</span>moco_img, <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), mean)
    }
  }</code></pre></div>
<p>It can also be informative to plot the data as a matrix, where each row is the time-series for a voxels. Due to the large number of voxels however, using just a sample of the voxels is much faster</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">nVox =<span class="st"> </span><span class="kw">length</span>(<span class="kw">which</span>(<span class="kw">as.array</span>(mask)<span class="op">==</span><span class="dv">1</span>))
vox =<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span>nVox, <span class="dv">1000</span>)
<span class="kw">invisible</span>(<span class="kw">plot</span>(<span class="kw">as.antsImage</span>( <span class="kw">t</span>(<span class="kw">timeseries2matrix</span>(img,mask)[,vox]))))
<span class="kw">invisible</span>(<span class="kw">plot</span>(<span class="kw">as.antsImage</span>( <span class="kw">t</span>(<span class="kw">timeseries2matrix</span>(moco<span class="op">$</span>moco_img,mask)[,vox]))))</code></pre></div>
<p>Plotting the registration parameters from the motion correction provides a qualitative feel for how much motion is in the data. In addition to the registration parameters, we plot the mean framewise displacement, which measures the average displacement of voxels, between consecutive time points.</p>
<p>Another metric that is typically plotted is the DVARS (D for temporal derivative, VARS for RMS variance over voxels) which illustrates the BOLD signal change across the brain between consecutive time points. First the BOLD signal is adjusted to have mean=1000 so that 10 units of BOLD value change = 1% signal change. While not necessary for a single-subject examination, this helps in inter-subject comparisons.</p>
</div>
<div id="identify-bad-time-points" class="section level3">
<h3>Identify “bad” time-points</h3>
<p>The motion parameters are often used to identify “bad” timepoints. A mean framewise displacement greater than 0.2mm is a common threshold used in human data. For illustrative purposes, we will use a threshold of 0.1 mm. Because the displacement is a measure of motion between two timepoints, both timepoints associated with the displacement are marked as bad.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">badtimes =<span class="st"> </span><span class="kw">which</span>(moco<span class="op">$</span>fd<span class="op">$</span>MeanDisplacement <span class="op">&gt;</span><span class="st"> </span>fdthresh )
<span class="cf">if</span> ( <span class="kw">length</span>( badtimes ) <span class="op">==</span><span class="st"> </span><span class="dv">0</span> ) badtimes =<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>)
badtimes =<span class="st"> </span><span class="kw">sort</span>(<span class="kw">c</span>(badtimes, badtimes<span class="op">+</span><span class="dv">1</span>))
goodtimes =<span class="st"> </span>(<span class="dv">1</span><span class="op">:</span>nTimes)[<span class="op">-</span>badtimes]</code></pre></div>
</div>
</div>
<div id="connectivity-processing" class="section level2">
<h2>Connectivity processing</h2>
<p>The steps here are:</p>
<ul>
<li><p>Demean and detrend the data</p></li>
<li><p>Regress out nuisance parameters</p></li>
<li><p>Frequency filtering</p></li>
<li><p>Spatial smoothing</p></li>
</ul>
<div id="detrending-the-data" class="section level3">
<h3>Detrending the data</h3>
<p>The time-series data is detrended while excluding the bad timepoints identified earlier. The global signal (mean signal over the whole brain) is used to illustrate the effect of the demeaning &amp; detrending.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">global_pre &lt;-<span class="st"> </span><span class="kw">rowMeans</span>(<span class="kw">timeseries2matrix</span>(img, mask))
global_moco &lt;-<span class="st"> </span><span class="kw">rowMeans</span>(<span class="kw">timeseries2matrix</span>(moco<span class="op">$</span>moco_img, mask))

boldMat =<span class="st"> </span><span class="kw">timeseries2matrix</span>(moco<span class="op">$</span>moco_img, mask)
boldMat[goodtimes,] =<span class="st"> </span><span class="kw">detrend</span>(boldMat[goodtimes,])
boldMat[badtimes,] =<span class="st"> </span><span class="ot">NA</span>

global_moco_detrend =<span class="st"> </span><span class="kw">rowMeans</span>(boldMat)
global_pre[badtimes] =<span class="st"> </span><span class="ot">NA</span>
global_moco[badtimes] =<span class="st"> </span><span class="ot">NA</span></code></pre></div>
</div>
<div id="collect-nuisance-parameters-to-regress-out" class="section level3">
<h3>Collect nuisance parameters to regress out</h3>
<p>Some typical nuisance parameters are</p>
<ul>
<li><p>detrended motion parameters, their squares, and the derivatives of both</p></li>
<li><p>mean signal in white matter &amp; it’s derivative</p></li>
<li><p>mean signal in CSF &amp; it’s derivative</p></li>
<li><p>physiologocial noise estimated via <code>compcor</code></p></li>
<li>global mean signal in brain &amp; it’s derivative</li>
<li><p>NOTE: this is a controversial topic, see below</p></li>
</ul>
<p>There are two camps when it comes to global signal, some leave it in, others regress it out. It is unclear which is best. Here we will include it as a nuisance parameter as done in the paper on which the methods are based. This should not be interpreted as an implied endorsement of one camp over the other. The values at “bad” timepoints are interpolated with splines so that derivatives may be calculated without “spreading” the influence of the bad time points.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># white matter is labeled as 3</span>
wmMask =<span class="st"> </span>seg2bold<span class="op">*</span><span class="dv">1</span><span class="op">*</span>mask
wmMask[ wmMask <span class="op">!=</span><span class="st"> </span><span class="dv">3</span>] =<span class="st"> </span><span class="dv">0</span>
wmMask[ wmMask <span class="op">==</span><span class="st"> </span><span class="dv">3</span> ] =<span class="st"> </span><span class="dv">1</span>
wmMask =<span class="st"> </span><span class="kw">iMath</span>( wmMask, <span class="st">&quot;ME&quot;</span>, <span class="dv">1</span>)
wmVox =<span class="st"> </span><span class="kw">which</span>(<span class="kw">subset</span>(wmMask, mask <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> )<span class="op">==</span><span class="dv">1</span>)
wmMean =<span class="st"> </span><span class="kw">rowMeans</span>(boldMat[,wmVox])

<span class="co"># CSF is labeled as 1</span>
csfMask =<span class="st"> </span>seg2bold<span class="op">*</span><span class="dv">1</span>
csfMask[ csfMask <span class="op">!=</span><span class="st"> </span><span class="dv">1</span>] =<span class="st"> </span><span class="dv">0</span>
<span class="co">#csfMask = iMath( csfMask, &quot;ME&quot;, 1)</span>
csfVox =<span class="st"> </span><span class="kw">which</span>(<span class="kw">subset</span>(csfMask, mask <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>)<span class="op">==</span><span class="dv">1</span>)
csfMean=<span class="st"> </span><span class="kw">rowMeans</span>(boldMat[,csfVox])
<span class="co">#csfMean = rowMeans(timeseries2matrix(detrendImg, csfMask))</span>

globalMean =<span class="st"> </span><span class="kw">rowMeans</span>(boldMat)
ncompcor =<span class="st"> </span><span class="dv">4</span>
compcorTemp =<span class="st"> </span><span class="kw">compcor</span>(boldMat[goodtimes,], <span class="dt">ncompcor =</span> ncompcor)
compcorNuis =<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, nTimes, ncompcor )
compcorNuis[goodtimes, ] =<span class="st"> </span>compcorTemp
compcorNuis[badtimes, ] =<span class="st"> </span><span class="ot">NA</span>
<span class="kw">colnames</span>( compcorNuis ) =<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;compcor&quot;</span>,<span class="dv">1</span><span class="op">:</span><span class="kw">ncol</span>(compcorNuis), <span class="dt">sep=</span><span class="st">''</span> )
tissueNuis =<span class="st"> </span><span class="kw">cbind</span>(globalMean, wmMean, csfMean)
<span class="cf">if</span> ( <span class="kw">length</span>(badtimes) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> ) {
  <span class="cf">for</span> ( v <span class="cf">in</span> <span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">dim</span>(tissueNuis)[<span class="dv">2</span>]) ) {
    tissueInterp =<span class="st"> </span><span class="kw">spline</span>( <span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span>nTimes)[goodtimes], tissueNuis[goodtimes,v],
      <span class="dt">method=</span><span class="st">'natural'</span>, <span class="dt">xout=</span>badtimes )<span class="op">$</span>y
    tissueNuis[badtimes,v]=tissueInterp
    }
  }
tissueDeriv =<span class="st"> </span><span class="kw">rbind</span>( <span class="kw">rep</span>(<span class="dv">0</span>,<span class="kw">dim</span>(tissueNuis)[<span class="dv">2</span>]), <span class="kw">diff</span>(tissueNuis,<span class="dv">1</span>) )</code></pre></div>
<p>The nuisance parameters are now regressed out the signal. This is illustrated by looking at the mean signal in the cortex before and after the regression.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mocoNuis =<span class="st"> </span><span class="kw">cbind</span>(reg_params, reg_params<span class="op">*</span>reg_params)
mocoNuis =<span class="st"> </span><span class="kw">detrend</span>(mocoNuis)
mocoDeriv =<span class="st"> </span><span class="kw">rbind</span>( <span class="kw">rep</span>(<span class="dv">0</span>,<span class="kw">dim</span>(mocoNuis)[<span class="dv">2</span>]), <span class="kw">diff</span>(mocoNuis,<span class="dv">1</span>) )

nuissance =<span class="st"> </span><span class="kw">cbind</span>( mocoNuis, mocoDeriv, tissueNuis, tissueDeriv, compcorNuis )

boldMat[goodtimes,] &lt;-<span class="st"> </span><span class="kw">residuals</span>( <span class="kw">lm</span>( boldMat[goodtimes,] <span class="op">~</span><span class="st"> </span>nuissance[goodtimes,] ) )</code></pre></div>
</div>
<div id="frequency-filtering" class="section level3">
<h3>Frequency filtering</h3>
<p>The next step is frequency filtering. However, first we want to fill in the “bad” timepoints with interpolated data. This is to avoid artifacts that would result from having non-evenly sampled time-series data. This bad timepoints will be again removed after the frequency filtering. Frequencies with the range of 0.009 Hz - 0.08 Hz are retained. In some cases it may be interesting to examine smaller subranges of frequencies to look for phenomena that occur at specific frequencies.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">if</span> ( <span class="kw">length</span>(badtimes) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> ) {
  <span class="cf">for</span> ( v <span class="cf">in</span> <span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span>nVox) ) {
    boldMat[badtimes,v]=<span class="kw">spline</span>( <span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span>nTimes)[goodtimes], boldMat[goodtimes,v],
      <span class="dt">method=</span><span class="st">'natural'</span>, <span class="dt">xout=</span>badtimes )<span class="op">$</span>y
    }
  }

<span class="co"># save interpolated values for plotting</span>
ctxMeanSpline =<span class="st"> </span><span class="kw">rowMeans</span>(boldMat[,ctxVox])

boldMat &lt;-<span class="st"> </span><span class="kw">frequencyFilterfMRI</span>( boldMat, <span class="dt">tr=</span>tr, <span class="dt">freqLo=</span><span class="fl">0.009</span>, <span class="dt">freqHi=</span><span class="fl">0.08</span>, <span class="dt">opt=</span><span class="st">&quot;trig&quot;</span> )

<span class="co"># save filtered values for plotting</span>
ctxMeanFiltered =<span class="st"> </span><span class="kw">rowMeans</span>(boldMat[,ctxVox])
ctxMeanFiltered[badtimes] =<span class="st"> </span><span class="ot">NA</span></code></pre></div>
</div>
<div id="spatial-smoothing" class="section level3">
<h3>Spatial smoothing</h3>
<p>Smoothing should be applied to all spatial dimensions, but the time dimension should be left alone. It is common to smooth with a Gaussian kernel with FWHM=6.0mm.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">img =<span class="st"> </span><span class="kw">matrix2timeseries</span>( img, mask, boldMat )
sptl =<span class="st"> </span><span class="kw">sqrt</span>( <span class="kw">sum</span>( <span class="kw">antsGetSpacing</span>(img)[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>]<span class="op">^</span><span class="dv">2</span>  ))
img =<span class="st"> </span><span class="kw">smoothImage</span>(img, <span class="kw">c</span>(<span class="kw">rep</span>(sptl,<span class="dv">3</span>),<span class="dv">0</span>), <span class="dt">FWHM=</span><span class="ot">TRUE</span> )
boldMat =<span class="st"> </span><span class="kw">timeseries2matrix</span>(img, mask)</code></pre></div>
</div>
</div>
<div id="building-networks" class="section level2">
<h2>Building networks</h2>
<div id="roi-definition" class="section level3">
<h3>ROI definition</h3>
<p>First, a set of ROIs is needed. While each individual voxel could be treated as an ROI, it is more common to define ROIs that contain many voxels and represent regions for which there is some a priori knowledge regarding the functional network to which each region belongs. The provided network definition used here lists the center point of each ROI so we must first create an image where each ROI is a sphere of radius=5mm centered on the provided point.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(powers_areal_mni_itk)
pts =<span class="st"> </span><span class="kw">antsApplyTransformsToPoints</span>( <span class="dv">3</span>, powers_areal_mni_itk, <span class="dt">transformlist =</span> mni2boldmapsInv )
pts[ , <span class="dv">4</span><span class="op">:</span><span class="kw">ncol</span>(pts) ] =<span class="st"> </span>powers_areal_mni_itk[ , <span class="dv">4</span><span class="op">:</span><span class="kw">ncol</span>(pts) ]
labelImg =<span class="st"> </span>mask<span class="op">*</span><span class="dv">0</span>
nPts =<span class="st"> </span><span class="kw">dim</span>(pts)[<span class="dv">1</span>]
rad =<span class="st"> </span><span class="dv">5</span>
n =<span class="st"> </span><span class="kw">ceiling</span>(rad <span class="op">/</span><span class="st"> </span><span class="kw">antsGetSpacing</span>(mask))

<span class="cf">for</span> ( r <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>nPts) {
  pt =<span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">c</span>(pts<span class="op">$</span>x[r], pts<span class="op">$</span>y[r], pts<span class="op">$</span>z[r] ))
  idx =<span class="st"> </span><span class="kw">antsTransformPhysicalPointToIndex</span>(mask,pt)

  <span class="cf">for</span> ( i <span class="cf">in</span> <span class="kw">c</span>(<span class="op">-</span>n[<span class="dv">1</span>]<span class="op">:</span>n[<span class="dv">1</span>]) ) {
    <span class="cf">for</span> (j <span class="cf">in</span> <span class="kw">c</span>(<span class="op">-</span>n[<span class="dv">2</span>]<span class="op">:</span>n[<span class="dv">2</span>])) {
      <span class="cf">for</span> (k <span class="cf">in</span> <span class="kw">c</span>(<span class="op">-</span>n[<span class="dv">3</span>]<span class="op">:</span>n[<span class="dv">3</span>])) {
        local =<span class="st"> </span>idx <span class="op">+</span><span class="st"> </span><span class="kw">c</span>(i,j,k)
        localpt =<span class="st"> </span><span class="kw">antsTransformIndexToPhysicalPoint</span>(mask,local)
        dist =<span class="st"> </span><span class="kw">sqrt</span>( <span class="kw">sum</span>( (localpt<span class="op">-</span>pt)<span class="op">*</span>(localpt<span class="op">-</span>pt) ))
        inImage =<span class="st"> </span>( <span class="kw">prod</span>(idx <span class="op">&lt;=</span><span class="st"> </span><span class="kw">dim</span>(mask))<span class="op">==</span><span class="dv">1</span>) <span class="op">&amp;&amp;</span><span class="st"> </span>( <span class="kw">length</span>(<span class="kw">which</span>(idx<span class="op">&lt;</span><span class="dv">1</span>)) <span class="op">==</span><span class="st"> </span><span class="dv">0</span> )
        <span class="cf">if</span> ( (dist <span class="op">&lt;=</span><span class="st"> </span>rad) <span class="op">&amp;&amp;</span><span class="st"> </span>( inImage <span class="op">==</span><span class="st"> </span><span class="ot">TRUE</span> ) ) {
          rlocal =<span class="st"> </span><span class="kw">round</span>( local )
          labelImg[ rlocal[<span class="dv">1</span>], rlocal[<span class="dv">2</span>], rlocal[<span class="dv">3</span>] ] =<span class="st"> </span>pts<span class="op">$</span>ROI[r]
         }
        }
      }
    }
  }
<span class="kw">plot</span>( meanbold, labelImg, <span class="dt">axis=</span><span class="dv">3</span>, <span class="dt">nslices=</span><span class="dv">30</span>, <span class="dt">ncolumns=</span><span class="dv">10</span>,
        <span class="dt">window.overlay =</span> <span class="kw">c</span>( <span class="dv">1</span>, <span class="kw">max</span>(labelImg) ) )</code></pre></div>
</div>
<div id="getting-roi-average-signals" class="section level3">
<h3>Getting ROI average signals</h3>
<p>Now that we have roi labels, we want to find the mean time signal for each ROI and then find the correlation matrix that give the correlation between each of these ROI signals. We need to be careful in the case where ROIs did not map into the image space and thus have 0 voxels.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">labelMask =<span class="st"> </span>labelImg<span class="op">*</span><span class="dv">1</span>
labelMask[labelMask <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>] =<span class="st"> </span><span class="dv">1</span>
labelMask[mask <span class="op">==</span><span class="st"> </span><span class="dv">0</span>] =<span class="st"> </span><span class="dv">0</span>
labelVox =<span class="st"> </span><span class="kw">which</span>(<span class="kw">subset</span>(labelMask, mask <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>)<span class="op">==</span><span class="dv">1</span>)

labeledBoldMat =<span class="st"> </span>boldMat[goodtimes,labelVox]
labels =<span class="st"> </span>labelImg[labelMask <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>]

nLabels =<span class="st"> </span><span class="kw">max</span>(labels)
roiMat =<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">nrow=</span><span class="kw">dim</span>(labeledBoldMat)[<span class="dv">1</span>], <span class="dt">ncol=</span>nLabels)
<span class="cf">for</span> ( i <span class="cf">in</span> <span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span>nLabels) ) {
  <span class="cf">if</span> (<span class="kw">length</span>(<span class="kw">which</span>(labels<span class="op">==</span>i)) <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span> ) {
    roiMat[,i] =<span class="st"> </span><span class="kw">rowMeans</span>(labeledBoldMat[,(labels<span class="op">==</span>i)])
  }
}
nActualTimes =<span class="st"> </span><span class="kw">dim</span>(roiMat)[<span class="dv">1</span>]</code></pre></div>
<p>Plot of the ROI averaged signals</p>
<p>If system labels are provided for the ROIs, it is possible to look at the mean and standard deviation for the BOLD signal within a system. Comparing the mean signal between systems provides some hints about how much those systems are working together, while the standard deviation ribbons indicate how cohesively the components of a given system are working.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">systemNames =<span class="st"> </span><span class="kw">levels</span>(pts<span class="op">$</span>SystemName)

nSystems =<span class="st"> </span><span class="kw">length</span>(systemNames)
sysMatMean =<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">nrow=</span><span class="kw">dim</span>(labeledBoldMat)[<span class="dv">1</span>], <span class="dt">ncol=</span>nSystems)
sysMatSD =<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">nrow=</span><span class="kw">dim</span>(labeledBoldMat)[<span class="dv">1</span>], <span class="dt">ncol=</span>nSystems)

systems =<span class="st"> </span>pts<span class="op">$</span>SystemName[labels]

<span class="cf">for</span> ( i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>nSystems ) {
  sys =<span class="st"> </span>systemNames[i]
  sysIdx =<span class="st"> </span><span class="kw">which</span>(systems<span class="op">==</span>sys)
  <span class="cf">if</span> ( <span class="kw">length</span>(sysIdx) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>)
    {
    sysMatMean[,i] =<span class="st"> </span><span class="kw">rowMeans</span>(labeledBoldMat[,sysIdx])
    sysMatSD[,i] =<span class="st"> </span><span class="kw">apply</span>(labeledBoldMat[,sysIdx], <span class="dv">1</span>, sd)
    }
}</code></pre></div>
<p>Create correlation matrix</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">missingROIs =<span class="st"> </span><span class="kw">which</span>(<span class="kw">colMeans</span>(roiMat)<span class="op">==</span><span class="dv">0</span>)
goodROIs =<span class="st"> </span>(<span class="dv">1</span><span class="op">:</span>nLabels)
<span class="cf">if</span> ( <span class="kw">length</span>(missingROIs) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> ) {
  goodROIs =<span class="st"> </span>goodROIs[<span class="op">-</span>missingROIs]
}

connMat =<span class="st"> </span><span class="kw">suppressWarnings</span>(<span class="kw">cor</span>(roiMat))
<span class="kw">diag</span>(connMat) =<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, <span class="kw">length</span>(<span class="kw">diag</span>(connMat)) )
<span class="cf">if</span> ( <span class="kw">length</span>(missingROIs) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> ) {
  connMat[missingROIs,] =<span class="st"> </span><span class="dv">0</span>
  connMat[,missingROIs] =<span class="st"> </span><span class="dv">0</span>
}</code></pre></div>
</div>
<div id="visualizing-constant-density-graphs" class="section level3">
<h3>Visualizing constant density graphs</h3>
<p>Networks are often created by using a constant density. For example, to create a network with density=0.1, we binarize the correlation matrix to retain 10% of the edges, favoring the egdes with the highest correlation values. The resulting adjacency matrix is then used to create a graph.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
density =<span class="st"> </span><span class="fl">0.1</span>
nEdges =<span class="st"> </span><span class="kw">length</span>(<span class="kw">upper.tri</span>(connMat))<span class="op">*</span>density
thresh =<span class="st"> </span><span class="kw">sort</span>( connMat[<span class="kw">upper.tri</span>(connMat)], <span class="dt">decreasing=</span>T)[nEdges]
adj =<span class="st"> </span><span class="dv">1</span><span class="op">*</span>(connMat <span class="op">&gt;=</span><span class="st"> </span>thresh)

bingraph =<span class="st"> </span><span class="kw">graph.adjacency</span>(adj, <span class="dt">mode=</span><span class="st">&quot;undirected&quot;</span>, <span class="dt">weighted=</span><span class="ot">NULL</span>)
components =<span class="st"> </span><span class="kw">clusters</span>(bingraph)
maxID =<span class="st"> </span><span class="kw">which</span>(components<span class="op">$</span>csize <span class="op">==</span><span class="st"> </span><span class="kw">max</span>(components<span class="op">$</span>csize))[<span class="dv">1</span>]

adj[components<span class="op">$</span>membership<span class="op">!=</span>maxID,] =<span class="st"> </span><span class="dv">0</span>
adj[,components<span class="op">$</span>membership<span class="op">!=</span>maxID] =<span class="st"> </span><span class="dv">0</span>
bingraph =<span class="st"> </span><span class="kw">graph.adjacency</span>(adj, <span class="dt">mode=</span><span class="st">&quot;undirected&quot;</span>, <span class="dt">weighted=</span><span class="ot">NULL</span>)

<span class="kw">invisible</span>(<span class="kw">plot</span>(<span class="kw">as.antsImage</span>(adj)))</code></pre></div>
<p>A more interesting way to visualize the adjacency matrix is to color the components by the system to which they belong. Of course, this requires that the ROIs used to define the network, include system identifies. In the plot, connections within a system are color coded while connections between systems are gray. For this type of plot, the order of the rows are sorted, so that nodes in the same system are clustered together.</p>
<p>It is also possible to export the data to a graphml file for visualization with an application such as <a href="http://gephi.github.io/">GEPHI</a>. In the example, the node colors are retained and edges for intra-system connections are colored the same as their nodes, while inter-system edges are gray.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="co"># Retain only the largest connected component</span>
bingraph =<span class="st"> </span><span class="kw">graph.adjacency</span>(adj, <span class="dt">mode=</span><span class="st">&quot;undirected&quot;</span>, <span class="dt">weighted=</span><span class="ot">NULL</span>)
components =<span class="st"> </span><span class="kw">clusters</span>(bingraph)
maxID =<span class="st"> </span><span class="kw">which</span>(components<span class="op">$</span>csize <span class="op">==</span><span class="st"> </span><span class="kw">max</span>(components<span class="op">$</span>csize))[<span class="dv">1</span>]

adj[components<span class="op">$</span>membership<span class="op">!=</span>maxID,] =<span class="st"> </span><span class="dv">0</span>
adj[,components<span class="op">$</span>membership<span class="op">!=</span>maxID] =<span class="st"> </span><span class="dv">0</span>
graph =<span class="st"> </span><span class="kw">graph.adjacency</span>( adj, <span class="dt">mode=</span><span class="st">&quot;undirected&quot;</span>, <span class="dt">weighted=</span><span class="ot">NULL</span> )

<span class="co"># Set node colors</span>
graph =<span class="st"> </span><span class="kw">set.vertex.attribute</span>(graph, <span class="st">&quot;r&quot;</span>, <span class="dt">index=</span><span class="kw">V</span>(graph), <span class="dt">value=</span><span class="kw">as.double</span>(pts<span class="op">$</span>r))
graph =<span class="st"> </span><span class="kw">set.vertex.attribute</span>(graph, <span class="st">&quot;g&quot;</span>, <span class="dt">index=</span><span class="kw">V</span>(graph), <span class="dt">value=</span><span class="kw">as.double</span>(pts<span class="op">$</span>g))
graph =<span class="st"> </span><span class="kw">set.vertex.attribute</span>(graph, <span class="st">&quot;b&quot;</span>, <span class="dt">index=</span><span class="kw">V</span>(graph), <span class="dt">value=</span><span class="kw">as.double</span>(pts<span class="op">$</span>b))

<span class="co"># Set edge colors</span>
edges =<span class="st"> </span><span class="kw">get.edges</span>( graph, <span class="kw">E</span>(graph) )
nEdges =<span class="st"> </span><span class="kw">dim</span>(edges)[<span class="dv">1</span>]
er =<span class="st"> </span><span class="kw">rep</span>(<span class="dv">200</span>, nEdges)
eg =<span class="st"> </span><span class="kw">rep</span>(<span class="dv">200</span>, nEdges)
eb =<span class="st"> </span><span class="kw">rep</span>(<span class="dv">200</span>, nEdges)

<span class="co"># colors for intra-system connections</span>
<span class="co">#  gray for inter-system connections</span>
<span class="cf">for</span> ( e <span class="cf">in</span> <span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span>nEdges) )
  {
  <span class="cf">if</span> ( pts<span class="op">$</span>SystemName[edges[e,<span class="dv">1</span>]] <span class="op">==</span><span class="st"> </span>pts<span class="op">$</span>SystemName[edges[e,<span class="dv">2</span>]] )
   {
    er[e] =<span class="st"> </span>pts<span class="op">$</span>r[edges[e,<span class="dv">1</span>]]
    eg[e] =<span class="st"> </span>pts<span class="op">$</span>g[edges[e,<span class="dv">1</span>]]
    eb[e] =<span class="st"> </span>pts<span class="op">$</span>b[edges[e,<span class="dv">1</span>]]
    }
  }

graph =<span class="st"> </span><span class="kw">set.edge.attribute</span>(graph, <span class="st">&quot;r&quot;</span>, <span class="dt">index=</span><span class="kw">E</span>(graph), <span class="dt">value=</span><span class="kw">as.double</span>(er))
graph =<span class="st"> </span><span class="kw">set.edge.attribute</span>(graph, <span class="st">&quot;g&quot;</span>, <span class="dt">index=</span><span class="kw">E</span>(graph), <span class="dt">value=</span><span class="kw">as.double</span>(eg))
graph =<span class="st"> </span><span class="kw">set.edge.attribute</span>(graph, <span class="st">&quot;b&quot;</span>, <span class="dt">index=</span><span class="kw">E</span>(graph), <span class="dt">value=</span><span class="kw">as.double</span>(eb))

<span class="co"># uncomment line below to write out graph</span>
<span class="co"># write.graph(graph, &quot;network.graphml&quot;, format=&quot;graphml&quot;, prefixAttr=FALSE)</span></code></pre></div>
</div>
</div>
<div id="graph-metrics" class="section level2">
<h2>Graph metrics</h2>
<p>Having derived a graph representation of the resting brain network, the next logical step is to examine graph-metrics that encapsulate various properties of the network. These are describe in further detail in a review of graph metrics for studying connectivity in the brain <span class="citation">(Rubinov and Sporns 2010)</span>. Two types of metrics will be examined.</p>
<ul>
<li><p>Node measures</p></li>
<li><p>Global network measures</p></li>
</ul>
<div id="node-measures" class="section level3">
<h3>Node measures</h3>
<p>The measures are made independently for each node/vertex in the graph. The following is a non-comprehensive list of possible node metrics</p>
<ul>
<li><p>Degree - the number of connections that include the node</p></li>
<li><p>Clustering coefficient - local neighborhood connectivity</p></li>
<li><p>Path length - mean shortest distance between this node and all others</p></li>
<li><p>Local efficiency - measures “closeness” off nodes in a neighborhood</p></li>
<li><p>Page-rank - Google page rank measure</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
graph =<span class="st"> </span><span class="kw">graph.adjacency</span>( adj, <span class="dt">mode=</span><span class="st">&quot;undirected&quot;</span>, <span class="dt">weighted=</span><span class="ot">NULL</span> )

deg =<span class="st"> </span><span class="kw">degree</span>(graph)
deg[deg<span class="op">==</span><span class="dv">0</span>] =<span class="st"> </span><span class="ot">NA</span>

pathsmat =<span class="st">  </span><span class="kw">shortest.paths</span>(graph, <span class="dt">weights=</span><span class="ot">NA</span>)
pathsmat[<span class="op">!</span><span class="kw">is.finite</span>(pathsmat)] =<span class="st"> </span><span class="ot">NA</span>
paths =<span class="st"> </span><span class="kw">rowMeans</span>(pathsmat, <span class="dt">na.rm=</span><span class="ot">TRUE</span>)
paths[paths<span class="op">==</span><span class="dv">0</span>] =<span class="st"> </span><span class="ot">NA</span>

clust =<span class="st"> </span><span class="kw">transitivity</span>(graph, <span class="dt">type=</span><span class="st">&quot;local&quot;</span>)
clust[deg <span class="op">&lt;</span><span class="st"> </span><span class="dv">2</span>] =<span class="st"> </span><span class="ot">NA</span>

pager =<span class="st"> </span><span class="kw">page.rank</span>(graph)<span class="op">$</span>vector
pager[deg <span class="op">&lt;</span><span class="st"> </span><span class="dv">2</span>] =<span class="st"> </span><span class="ot">NA</span>

<span class="co"># from http://pastebin.com/XqkEYtJS</span>
leff &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(deg))
goodnodes &lt;-<span class="st"> </span><span class="kw">which</span>(deg <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>)
leff[goodnodes] &lt;-<span class="st"> </span><span class="kw">sapply</span>(goodnodes, <span class="cf">function</span>(x) {
    neighbs &lt;-<span class="st"> </span><span class="kw">neighbors</span>(graph, <span class="dt">v=</span>x)
    g.sub &lt;-<span class="st"> </span><span class="kw">induced.subgraph</span>(graph, neighbs)
    Nv &lt;-<span class="st"> </span><span class="kw">vcount</span>(g.sub)

    lpaths &lt;-<span class="st"> </span><span class="kw">shortest.paths</span>(g.sub, <span class="dt">weights=</span><span class="ot">NA</span>)
    lpaths &lt;-<span class="st"> </span>paths[<span class="kw">upper.tri</span>(lpaths)]

    pathsup &lt;-<span class="st"> </span>lpaths[<span class="kw">upper.tri</span>(lpaths)]
    <span class="dv">2</span> <span class="op">/</span><span class="st"> </span>Nv <span class="op">/</span><span class="st"> </span>(Nv <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">*</span><span class="st"> </span><span class="kw">sum</span>(<span class="dv">1</span> <span class="op">/</span><span class="st"> </span>lpaths[<span class="kw">which</span>(<span class="kw">is.na</span>(lpaths)<span class="op">==</span><span class="ot">FALSE</span>)])
    }
  )
leff[deg <span class="op">&lt;</span><span class="st"> </span><span class="dv">2</span>] =<span class="st"> </span><span class="ot">NA</span>
leff[<span class="kw">which</span>(<span class="kw">is.na</span>(deg)<span class="op">==</span><span class="ot">TRUE</span>)] =<span class="st"> </span><span class="ot">NA</span></code></pre></div>
</div>
<div id="global-network-measures" class="section level3">
<h3>Global network measures</h3>
<p>The measures summarize the entire network in a single measure. All node metrics may be meaned over all nodes to obtain a global metric. Additional metrics include</p>
<ul>
<li><p>Global efficiency - closeness of nodes to all other nodes</p></li>
<li><p>Clustering coefficient - same as node based, but using entire graph as neighborhood</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
geff&lt;-<span class="dv">1</span><span class="op">/</span>(<span class="kw">shortest.paths</span>(graph))
geff[<span class="op">!</span><span class="kw">is.finite</span>(geff)]&lt;-<span class="ot">NA</span>
geff&lt;-<span class="kw">mean</span>(geff,<span class="dt">na.rm=</span><span class="ot">TRUE</span>)

cc =<span class="st"> </span><span class="kw">transitivity</span>(graph)</code></pre></div>
<p>Finally, make a dense map of the default mode network, using regression.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">refSignal =<span class="st"> </span>sysMatMean[ , systemNames <span class="op">==</span><span class="st"> &quot;Default Mode&quot;</span>  ]
<span class="co"># get priors for different networks</span>
<span class="cf">if</span> ( <span class="op">!</span><span class="st"> </span><span class="kw">exists</span>( <span class="st">&quot;networkPriors&quot;</span> ) )
  {
  networkPriors =<span class="st"> </span><span class="kw">getANTsRData</span>(<span class="st">&quot;fmrinetworks&quot;</span>)
  ilist =<span class="st"> </span>networkPriors<span class="op">$</span>images
  <span class="cf">for</span> ( i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(ilist) )
    ilist[[i]] =<span class="st"> </span><span class="kw">antsApplyTransforms</span>( meanbold, ilist[[i]], mni2boldmaps )
  }
pr =<span class="st"> </span><span class="kw">imageListToMatrix</span>( ilist, mask )
refSignal =<span class="st"> </span>( boldMat <span class="op">%*%</span><span class="st"> </span><span class="kw">t</span>(pr) )
networkDf =<span class="st"> </span><span class="kw">data.frame</span>( <span class="dt">ROI=</span>refSignal[goodtimes,<span class="dv">1</span>],  nuissance[goodtimes,] )
mdl =<span class="st"> </span><span class="kw">lm</span>( boldMat[goodtimes,] <span class="op">~</span><span class="st"> </span>. , <span class="dt">data=</span>networkDf )
bmdl =<span class="st"> </span><span class="kw">bigLMStats</span>( mdl, <span class="fl">1.e-4</span> )
betas =<span class="st"> </span>bmdl<span class="op">$</span>beta.t[<span class="st">&quot;ROI&quot;</span>,]
betasI =<span class="st"> </span><span class="kw">makeImage</span>( mask, betas )
loth =<span class="st"> </span><span class="kw">quantile</span>(  betas, <span class="dt">probs=</span><span class="fl">0.8</span> )
<span class="kw">plot</span>( meanbold, betasI, <span class="dt">axis=</span><span class="dv">3</span>, <span class="dt">nslices=</span><span class="dv">30</span>, <span class="dt">ncolumns=</span><span class="dv">10</span>,
        <span class="dt">window.overlay =</span> <span class="kw">c</span>( loth, <span class="kw">max</span>(betas) ) )</code></pre></div>
</div>
</div>
<div id="references" class="section level2 unnumbered">
<h2>References</h2>
<div id="refs" class="references">
<div id="ref-Power2012">
<p>Power, Jonathan D., Kelly A. Barnes, Abraham Z. Snyder, Bradley L. Schlaggar, and Steven E. Petersen. 2012. “Spurious but Systematic Correlations in Functional Connectivity Mri Networks Arise from Subject Motion.” <em>Neuroimage</em> 59 (3). Department of Neurology, Washington University School of Medicine, St. Louis, MO 63110, USA. powerj@wusm.wustl.edu: 2142–54. doi:<a href="https://doi.org/10.1016/j.neuroimage.2011.10.018">10.1016/j.neuroimage.2011.10.018</a>.</p>
</div>
<div id="ref-Power2014">
<p>Power, Jonathan D., Anish Mitra, Timothy O. Laumann, Abraham Z. Snyder, Bradley L. Schlaggar, and Steven E. Petersen. 2014. “Methods to Detect, Characterize, and Remove Motion Artifact in Resting State fMRI.” <em>Neuroimage</em> 84 (January). Dept. of Neurology, Washington University School of Medicine in St. Louis, 660 S. Euclid Ave., St. Louis, MO 63110, USA. Electronic address: powerj@wusm.wustl.edu.: 320–41. doi:<a href="https://doi.org/10.1016/j.neuroimage.2013.08.048">10.1016/j.neuroimage.2013.08.048</a>.</p>
</div>
<div id="ref-Rubinov2010">
<p>Rubinov, Mikail, and Olaf Sporns. 2010. “Complex Network Measures of Brain Connectivity: Uses and Interpretations.” <em>Neuroimage</em> 52 (3). Black Dog Institute; School of Psychiatry, University of New South Wales, Sydney, Australia.: 1059–69. doi:<a href="https://doi.org/10.1016/j.neuroimage.2009.10.003">10.1016/j.neuroimage.2009.10.003</a>.</p>
</div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
