---
title: "Optimizer Comparison for NSA-Flow"
author: "Cingulate R"
date: "October 17, 2025"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(ggplot2)
library(dplyr)
library(patchwork)
library(ANTsR)
library(gganimate)
library(scales)
```

```{r run_experiment,echo=FALSE}
# Initialize data
set.seed(123)
p <- 100; k <- 50
mat1 <- matrix(rnorm(p*k), p, k)
mat1 <- mat1 / norm(mat1, 'F')

# Transpose if needed (consistent with your setup)
if (exists("option") && option != "wide") mat1 <- t(mat1)

# Define experiment parameters
ws <- seq(0.05, 0.95, by = 0.05)
optimizers <- list_simlr_optimizers()
max_iter <- 15
tol <- 1e-5
if ( ! exists("raw_results") ) {
  raw_results <- data.frame()

  # Benchmark across optimizers
  for (o in optimizers) {
  #  cat(sprintf("\nRunning optimizer: %s\n", o))
    for (w in ws) {
      start_time <- Sys.time()
      res <- tryCatch({
        nsa_flow(mat1, w = w, verbose = FALSE, retraction = "soft_polar",
                optimizer = o, tol = tol, max_iter = max_iter)
      }, error = function(e) NULL)
      
      end_time <- Sys.time()
      runtime <- as.numeric(difftime(end_time, start_time, units = "secs"))
      
      if (!is.null(res)) {
        o_def <- invariant_orthogonality_defect(res$Y)
        fid <- norm(res$Y - res$target, "F") / norm(res$target, "F")
        raw_results <- rbind(raw_results, data.frame(
          Optimizer = o,
          w = w,
          Orthogonality = o_def,
          Fidelity = fid,
          Runtime = runtime
        ))
  #      cat(sprintf("  w=%.2f | Orth=%.4e | Fid=%.4e | t=%.2fs\n", w, o_def, fid, runtime))
      }
    }
  }
  write.csv(raw_results, "/tmp/nsa_optimizer_results.csv", row.names = FALSE)
}
```

---

## Static Visualizations

```{r ws_trends, fig.width=10, fig.height=12,echo=FALSE}
raw_results$Optimizer <- factor(raw_results$Optimizer, levels = unique(raw_results$Optimizer))

# Orthogonality trend
p1 <- ggplot(raw_results, aes(x = w, y = Orthogonality, color = Optimizer)) +
  geom_line(linewidth = 1) + geom_point(size = 2, alpha = 0.8) +
  geom_smooth(method = "loess", se = FALSE, linetype = "dashed", linewidth = 0.6) +
  facet_wrap(~Optimizer, scales = "free_y") +
  labs(
    title = "Orthogonality Defect vs. Retraction Weight (w)",
    y = "Orthogonality Defect (â†“)", x = "w"
  ) +
  theme_minimal(base_size = 14) + ylim(0,0.05)+
  theme(strip.text = element_text(face = "bold"),legend.position = "none")

# Fidelity trend
p2 <- ggplot(raw_results, aes(x = w, y = Fidelity, color = Optimizer)) +
  geom_line(linewidth = 1) + geom_point(size = 2, alpha = 0.8) +
  geom_smooth(method = "loess", se = FALSE, linetype = "dashed", linewidth = 0.6) +
  facet_wrap(~Optimizer, scales = "free_y") +
  labs(
    title = "Fidelity vs. Retraction Weight (w)",
    y = "Fidelity (â†“)", x = "w"
  ) +
  theme_minimal(base_size = 14) + ylim(0.1,2.0) +
  theme(strip.text = element_text(face = "bold"),legend.position = "none")

combined <- p1 / p2
ggsave("orth_fid_trends.png", combined, width = 10, height = 8, dpi = 300)
combined
```

---

<!--

## Animated Tradeoff Plot

```{r animation, fig.width=8, fig.height=6,eval=FALSE}
anim <- ggplot(raw_results, aes(x = Orthogonality, y = Fidelity, color = Optimizer)) +
  geom_point(size = 3, alpha = 0.8) +
  geom_path(linewidth = 1, alpha = 0.6) +
  transition_states(w, transition_length = 2, state_length = 1) +
  labs(
    title = "Fidelityâ€“Orthogonality Tradeoff by Optimizer",
    subtitle = "Retraction weight: {closest_state}",
    x = "Orthogonality Defect (â†“)",
    y = "Fidelity (â†“)",
    color = "Optimizer"
  ) +
  theme_minimal(base_size = 14) +
  theme(plot.title = element_text(face = "bold", hjust = 0.5))

anim_file <- "optimizer_tradeoff.gif"
animate(anim, width = 800, height = 600, res = 120, duration = 10, fps = 10)
anim_save(anim_file)
anim
```
-->

## Decision Analysis

```{r decision_analysis}
# Summaries
summary_df <- raw_results %>%
  group_by(Optimizer) %>%
  summarise(
    Mean_Defect = mean(Orthogonality, na.rm = TRUE),
    Mean_Fidelity = mean(Fidelity, na.rm = TRUE),
    Mean_Runtime = mean(Runtime, na.rm = TRUE),
    SD_Defect = sd(Orthogonality, na.rm = TRUE),
    SD_Fidelity = sd(Fidelity, na.rm = TRUE)
  )

# Normalize metrics (for fair weighting)
norm_df <- summary_df %>%
  mutate(
    Norm_Defect = rescale(Mean_Defect),
    Norm_Fid = rescale(Mean_Fidelity),
    Norm_Runtime = rescale(Mean_Runtime),
    Score_NoTime = Norm_Defect + Norm_Fid,
    Score_WithTime = Norm_Defect + Norm_Fid + Norm_Runtime
  )

# Best optimizer ignoring runtime
best_no_time <- norm_df$Optimizer[which.min(norm_df$Score_NoTime)]
best_with_time <- norm_df$Optimizer[which.min(norm_df$Score_WithTime)]

knitr::kable(norm_df, digits = 5, caption = "Optimizer Summary (Normalized Scores)")

cat(sprintf("\n**Best Optimizer (Ignoring Runtime):** %s\n", best_no_time))
cat(sprintf("**Best Optimizer (Including Runtime):** %s\n", best_with_time))
```

---

## Pareto Frontier

```{r pareto_plot, fig.width=10, fig.height=8,echo=FALSE}
if (!"Optimizer" %in% names(summary_df)) {
  summary_df$Optimizer <- factor(seq_len(nrow(summary_df)))
  warning("Column 'Optimizer' not found â€” assigning placeholder labels.")
} else {
  summary_df$Optimizer <- as.factor(summary_df$Optimizer)
}

pareto <- ggplot(summary_df[summary_df$Optimizer != 'amsgrad',], aes(
  x = Mean_Defect,
  y = Mean_Fidelity,
  color = Optimizer,
  size = Mean_Runtime
)) +
  geom_point(alpha = 0.8) +
  geom_text(aes(label = Optimizer), vjust = -1, size = 4) +
  labs(
    title = "Pareto Frontier: Fidelity vs Orthogonality Tradeoff",
    x = "Mean Orthogonality Defect (â†“)",
    y = "Mean Fidelity (â†“)"
  ) +
  theme_minimal(base_size = 14)+theme(legend.position = "none")

ggsave("pareto_frontier.png", pareto, width = 8, height = 5, dpi = 300)
pareto
```

---

### ðŸ§  Interpretation

* The **best optimizer (ignoring runtime)** minimizes both orthogonality defect and fidelity loss simultaneously.

* The **runtime-weighted best** may differ if one optimizer converges much faster with only a small performance loss.

* The **animated plot** shows each optimizerâ€™s *trajectory* in the orthogonalityâ€“fidelity plane as ( w ) increases, offering insight into tradeoffs between strong orthogonalization and fidelity preservation.
