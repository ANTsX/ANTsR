---
title: "Optimizer Comparison for NSA-Flow"
author: "Cingulate R"
date: "October 17, 2025"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(ggplot2)
library(dplyr)
library(patchwork)
library(ANTsR)
library(scales)
library(subtyper)
library(gt)
```

```{r run_experiment,echo=FALSE}
set.seed(123)
p <- 100; k <- 50
mat1 <- matrix(rnorm(p*k), p, k)
mat1 <- mat1 / norm(mat1, 'F')

# Transpose if needed (consistent with your setup)
if (exists("matoption") && matoption == "wide") mat1 <- t(mat1)

ws <- seq(0.05, 0.95, by = 0.05)
optimizers <- list_simlr_optimizers()
max_iter <- 500
tol <- 1e-6
def_ret <- "soft_polar"

if (!exists("raw_results")) {
  raw_results <- data.frame()

  for (o in optimizers) {
    for (w in ws) {
      start_time <- Sys.time()
      res <- tryCatch({
        nsa_flow(mat1, w = w, verbose = F, retraction = def_ret, simplified = FALSE,
                 optimizer = o, tol = tol, max_iter = max_iter, initial_learning_rate=0.01 )
      }, error = function(e) NULL)

      end_time <- Sys.time()
      runtime <- as.numeric(difftime(end_time, start_time, units = "secs"))

      if (!is.null(res)) {
        o_def <- invariant_orthogonality_defect(res$Y)
        fid <- norm(res$Y - res$target, "F") # / norm(res$target, "F")
        raw_results <- rbind(raw_results, data.frame(
          Optimizer = o,
          w = w,
          Orthogonality = o_def,
          Fidelity = fid,
          Runtime = runtime
        ))
      }
    }
  }
  write.csv(raw_results, "/tmp/nsa_optimizer_results.csv", row.names = FALSE)
}
```

---

## Static Visualizations

```{r ws_trends, fig.width=10, fig.height=12,echo=FALSE}
raw_results$Optimizer <- factor(raw_results$Optimizer, levels = unique(raw_results$Optimizer))

p1 <- ggplot(raw_results, aes(x = w, y = Orthogonality, color = Optimizer)) +
  geom_line(linewidth = 1) + geom_point(size = 2, alpha = 0.8) +
  geom_smooth(method = "loess", se = FALSE, linetype = "dashed", linewidth = 0.6) +
  facet_wrap(~Optimizer, scales = "free_y") +
  labs(title = "Orthogonality Defect vs Retraction Weight (w)",
       y = "Orthogonality Defect (â†“)", x = "w") +
  theme_minimal(base_size = 14) +
#  ylim(0, 0.05) +
  theme(strip.text = element_text(face = "bold"), legend.position = "none")

p2 <- ggplot(raw_results, aes(x = w, y = Fidelity, color = Optimizer)) +
  geom_line(linewidth = 1) + geom_point(size = 2, alpha = 0.8) +
  geom_smooth(method = "loess", se = FALSE, linetype = "dashed", linewidth = 0.6) +
  facet_wrap(~Optimizer, scales = "free_y") +
  labs(title = "Fidelity vs Retraction Weight (w)",
       y = "Fidelity (â†“)", x = "w") +
  theme_minimal(base_size = 14) +
#  ylim(0.1, 2.0) +
  theme(strip.text = element_text(face = "bold"), legend.position = "none")

combined <- p1 / p2
ggsave("orth_fid_trends.png", combined, width = 10, height = 8, dpi = 300)
combined
```

---

## Decision Analysis

```{r decision_analysis,echo=FALSE}
summary_df <- raw_results %>%
  group_by(Optimizer) %>%
  summarise(
    Mean_Defect = mean(Orthogonality, na.rm = TRUE),
    Mean_Fidelity = mean(Fidelity, na.rm = TRUE),
    Mean_Runtime = mean(Runtime, na.rm = TRUE),
    SD_Defect = sd(Orthogonality, na.rm = TRUE),
    SD_Fidelity = sd(Fidelity, na.rm = TRUE)
  )

norm_df <- summary_df %>%
  mutate(
    Norm_Defect = rescale(Mean_Defect),
    Norm_Fid = rescale(Mean_Fidelity),
    Norm_Runtime = rescale(Mean_Runtime),
    Score_NoTime = Norm_Defect + Norm_Fid,
    Score_WithTime = Norm_Defect + Norm_Fid + Norm_Runtime
  )

best_no_time <- norm_df$Optimizer[which.min(norm_df$Score_NoTime)]
best_with_time <- norm_df$Optimizer[which.min(norm_df$Score_WithTime)]

knitr::kable(norm_df, digits = 5, caption = "Optimizer Summary (Normalized Scores)")

cat(sprintf("\n**Best Optimizer (Ignoring Runtime):** %s\n", best_no_time))
cat(sprintf("**Best Optimizer (Including Runtime):** %s\n", best_with_time))
```

---

## Pareto Frontier

```{r pareto_plot, fig.width=10, fig.height=8,echo=FALSE}
if (!"Optimizer" %in% names(summary_df)) {
  summary_df$Optimizer <- factor(seq_len(nrow(summary_df)))
  warning("Column 'Optimizer' not found â€” assigning placeholder labels.")
} else {
  summary_df$Optimizer <- as.factor(summary_df$Optimizer)
}

pareto <- ggplot(summary_df, aes(
  x = Mean_Defect,
  y = Mean_Fidelity,
  color = Optimizer,
  size = Mean_Runtime
)) +
  geom_point(alpha = 0.8) +
  geom_text(aes(label = Optimizer), vjust = -1, size = 4) +
  labs(
    title = "Pareto Frontier: Fidelity vs Orthogonality Tradeoff",
    x = "Mean Orthogonality Defect (â†“)",
    y = "Mean Fidelity (â†“)"
  ) +
  theme_minimal(base_size = 14) + theme(legend.position = "none")

ggsave("pareto_frontier.png", pareto, width = 8, height = 5, dpi = 300)
pareto
```

---

## Multi-Criteria Ranking

```{r multi_criteria_ranking,echo=FALSE}
weights_df <- data.frame(
  metric_name = c("Mean_Defect", "Mean_Fidelity", "Mean_Runtime"),
  display_name = c("Orthogonality Defect", "Fidelity", "Runtime (s)"),
  weight = c(0.5, 0.5, 0.50),
  direction = c("low", "low", "low")
)

rank_results <- subtyper::rank_methods_by_performance(
  df = summary_df,
  id_col = "Optimizer",
  weights_df = weights_df,
  method = "rank",
  head_value = 10
)

rank_results$gt_table %>% fmt_number(
 columns = where(is.numeric), decimals = 3
) 
```

---

### ðŸ§  Interpretation

* **Without runtime:** prioritizes algorithmic accuracy â€” orthogonality and fidelity.
* **With runtime:** incorporates efficiency; slight tradeoffs tolerated for speed.
* **Pareto plot:** reveals whether an optimizer is *dominated* (worse on both metrics).
* **Top-ranked optimizers** balance all three dimensions quantitatively.
