<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Multichannel image proccessing • ANTsR</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">ANTsR</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="..//index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/ANTsR.html">Get Started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/antsrTransform.html">Using the antsrTransform class</a>
    </li>
    <li>
      <a href="../articles/deformationSimulation.html">Simulate a deformation field with ANTsR</a>
    </li>
    <li>
      <a href="../articles/iMath.html">iMath (mathematical operations inside ANTsR)</a>
    </li>
    <li>
      <a href="../articles/MultiChannel.html">Multichannel image proccessing</a>
    </li>
    <li>
      <a href="../articles/multivarTemplateCoordinates.html">multivariate template coordinates example for eigenanatomy</a>
    </li>
    <li>
      <a href="../articles/RestingBOLD.html">Resting BOLD (basic analyses using ANTsR)</a>
    </li>
    <li>
      <a href="../articles/rfLesionSeg.html">Multi-resolution voxel-wise neighborhood random forest (MRV-NRF) lesion segmentation</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Multichannel image proccessing</h1>
                        <h4 class="author">Jeffrey T. Duda</h4>
            
            <h4 class="date">2017-08-31</h4>
          </div>

    
    
<div class="contents">
<div id="overview" class="section level2">
<h2 class="hasAnchor">
<a href="#overview" class="anchor"></a>Overview</h2>
<p>This document provides some examples illustrating how <a href="https://github.com/stnava/ANTsR">ANTsR</a> may be used to work with multi channel images, such as rgb (i.e. color) data. This is still an extremely new feature and much of ANTsR does not yet support this image type. Examples will be added to this document as new functionality is implemented.</p>
</div>
<div id="basics" class="section level2">
<h2 class="hasAnchor">
<a href="#basics" class="anchor"></a>Basics</h2>
<p>Because ANTsR relies upon <a href="http://www.itk.org">ITK</a> for image IO, multichannel support is inherently built in. Basic conversions and math operations work as expected.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Read in and display header info</span>
img =<span class="st"> </span><span class="kw">antsImageRead</span>( <span class="kw">getANTsRData</span>(<span class="st">"decslice"</span>))
img
<span class="co">#&gt; antsImage</span>
<span class="co">#&gt;   Pixel Type          : float </span>
<span class="co">#&gt;   Components Per Pixel: 3 </span>
<span class="co">#&gt;   Dimensions          : 128x128 </span>
<span class="co">#&gt;   Voxel Spacing       : 1.875x1.875 </span>
<span class="co">#&gt;   Origin              : -119.3253 68.19728 </span>
<span class="co">#&gt;   Direction           : 1 0 0 -1</span>
img[<span class="dv">64</span>,<span class="dv">64</span>]
<span class="co">#&gt; , , 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;      [,1]</span>
<span class="co">#&gt; [1,]   17</span>
<span class="co">#&gt; [2,]   31</span>
<span class="co">#&gt; [3,]    2</span>

<span class="co"># Convert to an array</span>
arr =<span class="st"> </span><span class="kw">as.array</span>(img)
<span class="kw">dim</span>(arr)
<span class="co">#&gt; [1]   3 128 128</span>

<span class="co"># Convert array to multichannel antsImage</span>
img2 =<span class="st"> </span><span class="kw">as.antsImage</span>(arr, <span class="dt">components=</span><span class="ot">TRUE</span>)
img2
<span class="co">#&gt; antsImage</span>
<span class="co">#&gt;   Pixel Type          : float </span>
<span class="co">#&gt;   Components Per Pixel: 3 </span>
<span class="co">#&gt;   Dimensions          : 128x128 </span>
<span class="co">#&gt;   Voxel Spacing       : 1x1 </span>
<span class="co">#&gt;   Origin              : 0 0 </span>
<span class="co">#&gt;   Direction           : 1 0 0 1</span>

<span class="co"># Convert array to antsImage and set header info via reference image</span>
img2 =<span class="st"> </span><span class="kw">as.antsImage</span>(arr, <span class="dt">components=</span><span class="ot">TRUE</span>, <span class="dt">reference=</span>img )
img2
<span class="co">#&gt; antsImage</span>
<span class="co">#&gt;   Pixel Type          : float </span>
<span class="co">#&gt;   Components Per Pixel: 3 </span>
<span class="co">#&gt;   Dimensions          : 128x128 </span>
<span class="co">#&gt;   Voxel Spacing       : 1.875xNA </span>
<span class="co">#&gt;   Origin              : 68.19728 NA </span>
<span class="co">#&gt;   Direction           : 1 0 0 -1</span>

<span class="co"># Basic math ops work the same as for scalar images</span>
<span class="dv">2</span> *<span class="st"> </span><span class="kw">sum</span>(img)
<span class="co">#&gt; [1] 1140762</span>
<span class="kw">sum</span>(img *<span class="st"> </span><span class="dv">2</span>)
<span class="co">#&gt; [1] 1140762</span></code></pre></div>
<p>Many functions only work on scalar images, so here we split a multichannel image into a list of scalar images, then the <code>lapply</code> function provides a convenient way to process all channels.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Convert to list of scalar images</span>
iList =<span class="st"> </span><span class="kw">splitChannels</span>(img)
<span class="kw">plotColor</span>(iList)</code></pre></div>
<p><img src="MultiChannel_files/figure-html/lapply-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
sList =<span class="st"> </span><span class="kw">lapply</span>( iList, function(x) { <span class="kw">smoothImage</span>(x, <span class="fl">1.5</span>) } )
<span class="kw">plotColor</span>(sList)</code></pre></div>
<p><img src="MultiChannel_files/figure-html/lapply-2.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="co"># Merge back into multichannel image</span>
simg =<span class="st"> </span><span class="kw">mergeChannels</span>(sList)

<span class="co"># Write to file</span>
<span class="co"># antsImageWrite(simg, "smoothslice.nii.gz")</span></code></pre></div>
<p>It is worth mentioning that ANTsR is not yet compatible with <code>mclapply</code> as provided in the “parallel” package. It’s something we will be looking into in the future. The main problem has to do with allocating new images, some functions that only access existing data will work, however it does not guarantee a faster execution time.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">iMeans =<span class="st"> </span><span class="dv">0</span>
time1 =<span class="st"> </span><span class="dv">0</span>
timeParallel =<span class="st"> </span><span class="ot">NA</span>
if(<span class="st">"parallel"</span> %in%<span class="st"> </span><span class="kw">rownames</span>(<span class="kw">installed.packages</span>()) ==<span class="st"> </span><span class="ot">TRUE</span>) {
  ptm =<span class="st"> </span><span class="kw">proc.time</span>()
  iMeans =<span class="st"> </span><span class="kw">mclapply</span>( iList, function(x) <span class="kw">mean</span>(x), <span class="dt">mc.cores=</span><span class="kw">min</span>(<span class="kw">detectCores</span>(),<span class="dv">2</span>) )
  timeParallel =<span class="st"> </span><span class="kw">proc.time</span>() -<span class="st"> </span>ptm
  <span class="kw">unlist</span>(iMeans)
}
<span class="co">#&gt; [1] 10.99554 13.68597 10.13177</span>

ptm =<span class="st"> </span><span class="kw">proc.time</span>()
iMeans =<span class="st"> </span><span class="kw">lapply</span>(iList, function(x) <span class="kw">mean</span>(x) )
timeSerial =<span class="st"> </span><span class="kw">proc.time</span>() -<span class="st"> </span>ptm
<span class="kw">unlist</span>(iMeans)
<span class="co">#&gt; [1] 10.99554 13.68597 10.13177</span>

timeParallel
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;   0.005   0.016   0.034</span>
timeSerial
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;   0.005   0.002   0.007</span></code></pre></div>
</div>
<div id="working-with-diffusion-tensor-images" class="section level2">
<h2 class="hasAnchor">
<a href="#working-with-diffusion-tensor-images" class="anchor"></a>Working with diffusion tensor images</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt =<span class="st"> </span><span class="kw">antsImageRead</span>(<span class="kw">getANTsRData</span>(<span class="st">"dtislice"</span>))
dtList =<span class="st"> </span><span class="kw">splitChannels</span>(dt)

<span class="co"># Component of tensor are stored as: XX, XY, XZ, YY, YZ, ZZ</span>
trace =<span class="st"> </span>dtList[[<span class="dv">1</span>]] +<span class="st"> </span>dtList[[<span class="dv">4</span>]] +<span class="st"> </span>dtList[[<span class="dv">6</span>]]
trace[trace&lt;<span class="dv">0</span>] =<span class="st"> </span><span class="dv">0</span>
<span class="kw">plotColor</span>( trace )</code></pre></div>
<p><img src="MultiChannel_files/figure-html/dti1-1.png" width="672"></p>
<p>We only want to deal with voxels in the brain, so the <code>getMask</code> function is used to obtain rough estimate of the brain, and the image is plotted with background voxels tinted red.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mask =<span class="st"> </span><span class="kw">getMask</span>(trace)
<span class="kw">plotColor</span>( <span class="kw">list</span>(trace, trace*mask, trace*mask))</code></pre></div>
<p><img src="MultiChannel_files/figure-html/dti2-1.png" width="672"></p>
<p>Since we are only interested in voxels in the brain, a matrix is created where each row is voxel in the brain and each column in a tensor component, listed in upper.tri order. This allows us to quickly calculate the eigen decomposition for each tensor.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># list-based call to convert values to an array</span>
mat =<span class="st"> </span><span class="kw">do.call</span>(rbind, <span class="kw">lapply</span>( dtList, function(x) { x[mask&gt;<span class="dv">0</span>] } ) )

<span class="co"># simplest convesion to array</span>
<span class="co"># mat = as.array(dt, mask == 1)</span>

<span class="co"># convert tensor from vector to matrix</span>
initTensor &lt;-<span class="st"> </span>function(x) {
  tens =<span class="st"> </span><span class="kw">diag</span>(<span class="dv">3</span>)
  tens[<span class="kw">lower.tri</span>(tens, <span class="dt">diag=</span><span class="ot">TRUE</span>)] =<span class="st"> </span>x
  tens =<span class="st"> </span>tens +<span class="st"> </span><span class="kw">t</span>(tens) -<span class="st"> </span><span class="kw">diag</span>(<span class="kw">diag</span>(tens))
  <span class="kw">return</span>(tens)
  }

getFractionalAnisotropy &lt;-<span class="st"> </span>function(evs) {
  numer =<span class="st"> </span><span class="kw">sqrt</span>( (evs[<span class="dv">1</span>]-evs[<span class="dv">2</span>])^<span class="dv">2</span> +<span class="st"> </span>(evs[<span class="dv">2</span>]-evs[<span class="dv">3</span>])^<span class="dv">2</span> +<span class="st"> </span>(evs[<span class="dv">3</span>]-evs[<span class="dv">1</span>])^<span class="dv">2</span> )
  denom =<span class="st"> </span><span class="kw">sqrt</span>( <span class="kw">sum</span>(evs*evs) )
  fa =<span class="st"> </span><span class="dv">0</span>
  if ( denom &gt;<span class="st"> </span><span class="dv">0</span> ) {
    fa =<span class="st"> </span><span class="kw">sqrt</span>(<span class="fl">0.5</span>) *<span class="st"> </span>numer/denom
  }
  fa
  }

<span class="co"># Eigen decomposition for each tensor</span>
<span class="co"># eigs = unlist( apply(mat, 2, function(x) {</span>
<span class="co">#   eigen( initTensor(x) )</span>
<span class="co">#   } )</span>
<span class="co">#   )</span>

all_eigs =<span class="st"> </span><span class="kw">apply</span>(mat, <span class="dv">2</span>, function(x) {
  <span class="kw">eigen</span>( <span class="kw">initTensor</span>(x) )
  } )

eigs =<span class="st"> </span><span class="kw">lapply</span>(all_eigs, function(x) {
  x$values
})
eigs =<span class="st"> </span><span class="kw">lapply</span>(eigs, unlist)
evalMat =<span class="st"> </span><span class="kw">do.call</span>(rbind, eigs)
evalMat[evalMat &lt;<span class="st"> </span><span class="dv">0</span> ] =<span class="st"> </span><span class="dv">0</span>

<span class="co"># Create images from the eigenvalues</span>
eval1 =<span class="st"> </span><span class="kw">makeImage</span>(mask, evalMat[,<span class="dv">1</span>])
eval2 =<span class="st"> </span><span class="kw">makeImage</span>(mask, evalMat[,<span class="dv">2</span>])
eval3 =<span class="st"> </span><span class="kw">makeImage</span>(mask, evalMat[,<span class="dv">3</span>])

<span class="kw">plotColor</span>( <span class="kw">list</span>(eval1, eval2, eval3))</code></pre></div>
<p><img src="MultiChannel_files/figure-html/dti3-1.png" width="672"></p>
<p>The Fractional Anisotropy (FA) is typically used to measure how directionally specific the diffusion of water is within a voxel. This values is plotted below</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">faValues =<span class="st"> </span><span class="kw">apply</span>(evalMat, <span class="dv">1</span>, getFractionalAnisotropy )
faValues[faValues &lt;<span class="st"> </span><span class="dv">0</span>] =<span class="st"> </span><span class="dv">0</span>
fa =<span class="st"> </span><span class="kw">makeImage</span>(mask, faValues)
<span class="kw">plotColor</span>( fa )</code></pre></div>
<p><img src="MultiChannel_files/figure-html/dti4-1.png" width="672"></p>
<p>Also of great interest is the eigenvector associated with the largest eigenvalue, this estimates the primary direction of diffusion (PDD) and in white matter this corresponds to the direction that is parallel to the myelinated axons in a fiber bundle</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">eig_vecs =<span class="st"> </span><span class="kw">lapply</span>(all_eigs, function(x) {
  x$vectors
})
eig_vecs =<span class="st"> </span><span class="kw">lapply</span>(eig_vecs, c)
vecMat =<span class="st"> </span><span class="kw">do.call</span>(rbind, eig_vecs)


evecx =<span class="st"> </span><span class="kw">makeImage</span>(mask, vecMat[,<span class="dv">1</span>])
evecy =<span class="st"> </span><span class="kw">makeImage</span>(mask, vecMat[,<span class="dv">2</span>])
evecz =<span class="st"> </span><span class="kw">makeImage</span>(mask, vecMat[,<span class="dv">3</span>])
decList =<span class="st"> </span><span class="kw">list</span>(evecx, evecy, evecz)
decList =<span class="st"> </span><span class="kw">lapply</span>(decList, abs)

<span class="kw">plotColor</span>( decList )</code></pre></div>
<p><img src="MultiChannel_files/figure-html/dti5-1.png" width="672"></p>
<p>Weighting the magnitude of the PDD by the FA is standard practice as it highlights regions with high directional specificity (i.e. white matter). This is known as a directional encoded colormap (DEC) <span class="citation">(Pajevic and Pierpaoli 1999)</span></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">decList =<span class="st"> </span><span class="kw">lapply</span>( decList, function(x){ fa*x } )
<span class="kw">plotColor</span>(decList)</code></pre></div>
<p><img src="MultiChannel_files/figure-html/dti6-1.png" width="672"></p>
<p>To verify our processing, it can be useful to plot line segments showing the direction of some of the vectors. This is done in a subset of the image to avoid too much visual clutter.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lower =<span class="st"> </span><span class="kw">c</span>(<span class="dv">40</span>,<span class="dv">80</span>)
upper =<span class="st"> </span><span class="kw">c</span>(<span class="dv">80</span>,<span class="dv">120</span>)
subfa =<span class="st"> </span><span class="kw">cropIndices</span>(fa, <span class="dt">lowerind =</span> lower, <span class="dt">upperind =</span> upper)
subVecList =<span class="st"> </span><span class="kw">list</span>(evecx, evecy, evecz)
subVecList =<span class="st"> </span><span class="kw">lapply</span>( subVecList, function(x){ <span class="kw">cropIndices</span>(x, <span class="dt">lowerind =</span> lower, <span class="dt">upperind =</span> upper)})
subDecList =<span class="st"> </span><span class="kw">lapply</span>( subVecList, function(x){ <span class="kw">abs</span>(subfa*x) })

<span class="kw">plotColor</span>( subDecList, <span class="dt">vectors=</span><span class="kw">list</span>(subVecList[[<span class="dv">1</span>]], subVecList[[<span class="dv">2</span>]]) )</code></pre></div>
<p><img src="MultiChannel_files/figure-html/dti7-1.png" width="672"></p>
</div>
<div id="deterministic-fiber-tractography" class="section level2">
<h2 class="hasAnchor">
<a href="#deterministic-fiber-tractography" class="anchor"></a>Deterministic Fiber tractography</h2>
<p>A common use for DTI is fiber tractography <span class="citation">(Basser et al. 2000)</span>. Here we give a simplified example in which we restrict the tracts to lie within the slice. The first step is define a set of seeds which serve as the starting points for our tractography. Often, all points in the white matter are used as seed for “whole-brain tracking.” Here we manually define a small set of seed points for illustration.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="co"># indices of seed points</span>
seedIndices =<span class="st"> </span><span class="kw">rbind</span>( <span class="kw">c</span>(<span class="dv">61</span>,<span class="dv">92</span>), <span class="kw">c</span>(<span class="dv">62</span>,<span class="dv">92</span>), <span class="kw">c</span>(<span class="dv">63</span>,<span class="dv">92</span>) )
seedIndices =<span class="st"> </span><span class="kw">rbind</span>( seedIndices, <span class="kw">c</span>(<span class="dv">64</span>,<span class="dv">92</span>), <span class="kw">c</span>(<span class="dv">65</span>,<span class="dv">92</span>), <span class="kw">c</span>(<span class="dv">65</span>,<span class="dv">92</span>) )
seedIndices =<span class="st"> </span><span class="kw">rbind</span>( seedIndices, <span class="kw">c</span>(<span class="dv">61</span>,<span class="dv">93</span>), <span class="kw">c</span>(<span class="dv">62</span>,<span class="dv">93</span>), <span class="kw">c</span>(<span class="dv">63</span>,<span class="dv">93</span>) )
seedIndices =<span class="st"> </span><span class="kw">rbind</span>( seedIndices, <span class="kw">c</span>(<span class="dv">64</span>,<span class="dv">93</span>), <span class="kw">c</span>(<span class="dv">65</span>,<span class="dv">93</span>), <span class="kw">c</span>(<span class="dv">65</span>,<span class="dv">93</span>) )

<span class="co"># convert to physical space points</span>
seedPts =<span class="st"> </span><span class="kw">antsTransformIndexToPhysicalPoint</span>(fa, seedIndices)
<span class="kw">plotColor</span>( subfa, <span class="dt">points=</span>seedPts )</code></pre></div>
<p><img src="MultiChannel_files/figure-html/seeds-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">trackFromSeed &lt;-<span class="st"> </span>function(vecs, fa, seed) {
  stepSize =<span class="st"> </span><span class="fl">0.2</span>
  faThresh =<span class="st"> </span><span class="fl">0.2</span>
  iPt =<span class="st"> </span>seed
  pts =<span class="st"> </span>iPt
  idx =<span class="st">  </span><span class="kw">antsTransformPhysicalPointToIndex</span>(fa, seed)
  faValue =<span class="st"> </span>fa[idx[<span class="dv">1</span>], idx[<span class="dv">2</span>]]
  ppdx =<span class="st"> </span>vecs[[<span class="dv">1</span>]][ idx[<span class="dv">1</span>], idx[<span class="dv">2</span>] ]
  ppdy =<span class="st"> </span>vecs[[<span class="dv">2</span>]][ idx[<span class="dv">1</span>], idx[<span class="dv">2</span>] ]
  lastVec =<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">antsGetDirection</span>(fa) %*%<span class="st"> </span><span class="kw">as.matrix</span>(<span class="kw">c</span>(ppdx,ppdy)))
  iVec =<span class="st"> </span>lastVec

  while ( faValue &gt;<span class="st"> </span>faThresh ) {
    iVec =<span class="st"> </span>iVec /<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">sum</span>(iVec*iVec))
    if ( <span class="kw">sum</span>(iVec*lastVec) &lt;<span class="st">  </span><span class="dv">0</span> ) { iVec =<span class="st"> </span>-iVec }

    iPt =<span class="st"> </span>iPt +<span class="st"> </span>stepSize*iVec
    pts =<span class="st"> </span><span class="kw">rbind</span>(pts, iPt)
    idx =<span class="st">  </span><span class="kw">antsTransformPhysicalPointToIndex</span>(fa, iPt)
    faValue =<span class="st"> </span>fa[idx[<span class="dv">1</span>], idx[<span class="dv">2</span>]]
    lastVec =<span class="st"> </span>iVec

    ppdx =<span class="st"> </span>vecs[[<span class="dv">1</span>]][ idx[<span class="dv">1</span>], idx[<span class="dv">2</span>] ]
    ppdy =<span class="st"> </span>vecs[[<span class="dv">2</span>]][ idx[<span class="dv">1</span>], idx[<span class="dv">2</span>] ]
    iVec =<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">antsGetDirection</span>(fa) %*%<span class="st"> </span><span class="kw">as.matrix</span>(<span class="kw">c</span>(ppdx,ppdy)))
  }

  iPt =<span class="st"> </span>seed
  idx =<span class="st">  </span><span class="kw">antsTransformPhysicalPointToIndex</span>(fa, seed)
  faValue =<span class="st"> </span>fa[idx[<span class="dv">1</span>], idx[<span class="dv">2</span>]]
  vecs =<span class="st"> </span><span class="kw">lapply</span>( vecs, function(x){ -x })
  ppdx =<span class="st"> </span>vecs[[<span class="dv">1</span>]][ idx[<span class="dv">1</span>], idx[<span class="dv">2</span>] ]
  ppdy =<span class="st"> </span>vecs[[<span class="dv">2</span>]][ idx[<span class="dv">1</span>], idx[<span class="dv">2</span>] ]
  lastVec =<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">antsGetDirection</span>(fa) %*%<span class="st"> </span><span class="kw">as.matrix</span>(<span class="kw">c</span>(ppdx,ppdy)))
  iVec =<span class="st"> </span>lastVec

  while ( faValue &gt;<span class="st"> </span>faThresh ) {
    iVec =<span class="st"> </span>iVec /<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">sum</span>(iVec*iVec))
    if ( <span class="kw">sum</span>(iVec*lastVec) &lt;<span class="st">  </span><span class="dv">0</span> ) { iVec =<span class="st"> </span>-iVec }

    iPt =<span class="st"> </span>iPt +<span class="st"> </span>stepSize*iVec
    pts =<span class="st"> </span><span class="kw">rbind</span>(iPt, pts)
    idx =<span class="st">  </span><span class="kw">antsTransformPhysicalPointToIndex</span>(fa, iPt)
    faValue =<span class="st"> </span>fa[idx[<span class="dv">1</span>], idx[<span class="dv">2</span>]]
    lastVec =<span class="st"> </span>iVec

    ppdx =<span class="st"> </span>vecs[[<span class="dv">1</span>]][ idx[<span class="dv">1</span>], idx[<span class="dv">2</span>] ]
    ppdy =<span class="st"> </span>vecs[[<span class="dv">2</span>]][ idx[<span class="dv">1</span>], idx[<span class="dv">2</span>] ]
    iVec =<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">antsGetDirection</span>(fa) %*%<span class="st"> </span><span class="kw">as.matrix</span>(<span class="kw">c</span>(ppdx,ppdy)))
  }

  <span class="kw">return</span>(<span class="kw">data.frame</span>(<span class="dt">x=</span>pts[,<span class="dv">1</span>],<span class="dt">y=</span>pts[,<span class="dv">2</span>]))

}

trackx =<span class="st"> </span><span class="kw">c</span>()
tracky =<span class="st"> </span><span class="kw">c</span>()
trackid =<span class="st"> </span><span class="kw">c</span>()
for ( i in <span class="dv">1</span>:<span class="kw">dim</span>(seedPts)[<span class="dv">1</span>] ) {
  track =<span class="st"> </span><span class="kw">trackFromSeed</span>(<span class="kw">list</span>(evecx,evecy), fa, seedPts[i,])
  trackx =<span class="st"> </span><span class="kw">c</span>(trackx,track$x)
  tracky =<span class="st"> </span><span class="kw">c</span>(tracky,track$y)
  trackid =<span class="st"> </span><span class="kw">c</span>(trackid, <span class="kw">rep</span>(i, <span class="kw">length</span>(track$x)))  
}
ldat =<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x=</span>trackx, <span class="dt">y=</span>tracky, <span class="dt">id=</span><span class="kw">factor</span>(trackid))
<span class="kw">plotColor</span>(subDecList, <span class="dt">paths=</span>ldat, <span class="dt">points=</span>seedPts, <span class="dt">vectors=</span><span class="kw">list</span>(subVecList[[<span class="dv">1</span>]], subVecList[[<span class="dv">2</span>]]))</code></pre></div>
<p><img src="MultiChannel_files/figure-html/tracking-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotColor</span>(subfa, <span class="dt">paths=</span>ldat, <span class="dt">points=</span>seedPts)</code></pre></div>
<p><img src="MultiChannel_files/figure-html/tracking-2.png" width="672"></p>
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h2>
<div id="refs" class="references">
<div id="ref-Basser2000">
<p>Basser, P. J., S. Pajevic, C. Pierpaoli, J. Duda, and A. Aldroubi. 2000. “In Vivo Fiber Tractography Using Dt-Mri Data.” <em>Magn Reson Med</em> 44 (4). Section on Tissue Biophysics; Biomimetics, NICHD, Bethesda, Maryland 20892-5772, USA. pjbasser@helix.nih.gov: 625–32.</p>
</div>
<div id="ref-Pajevic1999">
<p>Pajevic, S., and C. Pierpaoli. 1999. “Color Schemes to Represent the Orientation of Anisotropic Tissues from Diffusion Tensor Data: Application to White Matter Fiber Tract Mapping in the Human Brain.” <em>Magn Reson Med</em> 42 (3). Mathematical; Statistical Computing Laboratory, Center for Information Technology, National Institutes of Health, Bethesda, Maryland, USA.: 526–40.</p>
</div>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#overview">Overview</a></li>
      <li><a href="#basics">Basics</a></li>
      <li><a href="#working-with-diffusion-tensor-images">Working with diffusion tensor images</a></li>
      <li><a href="#deterministic-fiber-tractography">Deterministic Fiber tractography</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Brian B Avants.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
