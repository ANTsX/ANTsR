<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Using the antsrTransform class • ANTsR</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">ANTsR</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="..//index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/ANTsR.html">Get Started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/antsrTransform.html">Using the antsrTransform class</a>
    </li>
    <li>
      <a href="../articles/deformationSimulation.html">Simulate a deformation field with ANTsR</a>
    </li>
    <li>
      <a href="../articles/iMath.html">iMath (mathematical operations inside ANTsR)</a>
    </li>
    <li>
      <a href="../articles/MultiChannel.html">Multichannel image proccessing</a>
    </li>
    <li>
      <a href="../articles/multivarTemplateCoordinates.html">multivariate template coordinates example for eigenanatomy</a>
    </li>
    <li>
      <a href="../articles/RestingBOLD.html">Resting BOLD (basic analyses using ANTsR)</a>
    </li>
    <li>
      <a href="../articles/rfLesionSeg.html">Multi-resolution voxel-wise neighborhood random forest (MRV-NRF) lesion segmentation</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Using the antsrTransform class</h1>
                        <h4 class="author">Jeffrey T. Duda</h4>
            
            <h4 class="date">2017-08-23</h4>
          </div>

    
    
<div class="contents">
<div id="overview" class="section level2">
<h2 class="hasAnchor">
<a href="#overview" class="anchor"></a>Overview</h2>
<p>This document provides some examples illustrating how <a href="https://github.com/stnava/ANTsR">ANTsR</a> may be used to work with spatial transforms. This class is based upon the <a href="http://www.itk.org/Doxygen/html/classitk_1_1Transform.html">itk::Transform</a> class which provides the underlying implementations. This class may be used to apply spatial transforms to points, vectors, and images.</p>
</div>
<div id="transforming-point-and-vector-data" class="section level2">
<h2 class="hasAnchor">
<a href="#transforming-point-and-vector-data" class="anchor"></a>Transforming point and vector data</h2>
<p>To demonstrate the methods, we will first create a linear transform and demonstrate its application to point and vector data. An <code>AffineTransform</code> is created then defined by setting its parameters. These parameters are the components of the matrix, in row order, followed by the translation components. If no parameters are set, an identity transform is returned. Parameters may be changed later using <code>setAntsrTransformParameters</code> and <code>setAntsrTransformFixedarameters</code>. The difference between Parameters and FixedParameters, is that the parameters are considered by optimization problems such as image registration, while the fixed parameters are not considered by the optimization. For a given transform type, the parameters and fixed parameters are described in a later section.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tx &lt;-<span class="st"> </span><span class="kw">createAntsrTransform</span>( <span class="dt">precision=</span><span class="st">"float"</span>, <span class="dt">type=</span><span class="st">"AffineTransform"</span>, <span class="dt">dimension=</span><span class="dv">2</span>)
<span class="kw">setAntsrTransformParameters</span>(tx, <span class="kw">c</span>(<span class="dv">0</span>,-<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>))
<span class="kw">setAntsrTransformFixedParameters</span>(tx, <span class="kw">c</span>(<span class="dv">128</span>,<span class="dv">128</span>))
<span class="kw">print</span>(tx)
<span class="co">#&gt; antsrTransform</span>
<span class="co">#&gt;   Dimensions    : 2 </span>
<span class="co">#&gt;   Precision     : float </span>
<span class="co">#&gt;   Type          : AffineTransform</span>

point =<span class="st"> </span><span class="kw">c</span>(<span class="dv">80</span>,<span class="dv">40</span>)
outpoint =<span class="st"> </span><span class="kw">applyAntsrTransform</span>(tx, point)
<span class="kw">print</span>(outpoint)
<span class="co">#&gt; [1] 216  80</span></code></pre></div>
<p>This transforms may be applied to a set of points using <code>apply</code> and its variants.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ptsMat =<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">80</span>,<span class="dv">40</span>), <span class="kw">c</span>(<span class="dv">20</span>,<span class="dv">30</span>))
<span class="kw">t</span>(<span class="kw">apply</span>( ptsMat, <span class="dv">1</span>, function(x) {<span class="kw">applyAntsrTransform</span>(tx, x)}))
<span class="co">#&gt;      [,1] [,2]</span>
<span class="co">#&gt; [1,]  216   80</span>
<span class="co">#&gt; [2,]  226   20</span>

ptsList =<span class="st"> </span><span class="kw">list</span>(<span class="kw">c</span>(<span class="dv">80</span>,<span class="dv">40</span>), <span class="kw">c</span>(<span class="dv">20</span>,<span class="dv">30</span>))
<span class="kw">lapply</span>( ptsList, function(x) {<span class="kw">applyAntsrTransform</span>(tx, x)})
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 216  80</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] 226  20</span></code></pre></div>
<p>Linear transforms may be inverted, but non-linear transforms may not be directly inverted. See later sections for more on non-linear transforms.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">itx =<span class="st"> </span><span class="kw">invertAntsrTransform</span>(tx)
<span class="kw">applyAntsrTransform</span>( itx, outpoint )
<span class="co">#&gt; [1] 80 40</span></code></pre></div>
<p>Applying a transform to a vector is not the same as applying the transform to a point since a vector does not have a spatial location but rather is a direction. Clearly, it is important to set the dataType correctly (default is “point” if input data is not an <code>antsImage</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">vector =<span class="st"> </span><span class="kw">c</span>(<span class="dv">80</span>,<span class="dv">40</span>)
<span class="kw">applyAntsrTransform</span>(tx, vector, <span class="dt">dataType=</span><span class="st">"vector"</span>)
<span class="co">#&gt; [1] -40  80</span></code></pre></div>
</div>
<div id="nomenclature-talking-about-talking-about-transforms" class="section level2">
<h2 class="hasAnchor">
<a href="#nomenclature-talking-about-talking-about-transforms" class="anchor"></a>Nomenclature: talking about talking about transforms</h2>
<p>To discuss more complex operations such as transform composition and the transforming of images, it is helpful to define a nomenclature. The nomenclature used here is based upon that defined by <a href="http://journal.frontiersin.org/article/10.3389/fninf.2014.00044/full">Avants et. al.</a>.</p>
<p>A physical point: <span class="math inline">\(x \in \Omega\)</span> where <span class="math inline">\(\Omega\)</span> is the domain, usually of an image</p>
<p>An image: <span class="math inline">\(I \colon \Omega^d \rightarrow \mathbb{R}^n\)</span> where n is the number of components per pixel and <span class="math inline">\(d\)</span> is dimensionality. A second image is J.</p>
<p>Domain map: <span class="math inline">\(\phi \colon \Omega_i \rightarrow \Omega_j\)</span> where <span class="math inline">\(\rightarrow\)</span> may be replaced with any mapping symbol</p>
<p>Affine mapping: <span class="math inline">\(\leftrightarrow\)</span> a low-dimensional invertible transform: affine, rigid, translation, etc.</p>
<p>Affine mapping: <span class="math inline">\(\rightarrow\)</span> designates the direction an affine mapping is applied.</p>
<p>Deformation field: <span class="math inline">\(\rightsquigarrow\)</span> deformation field mapping J to I. May not be invertible.</p>
<p>Spline-based deformation field: <span class="math inline">\(\substack{ \rightsquigarrow \\ b }\)</span> e.g., B-Spline field mapping <span class="math inline">\(J\)</span> to <span class="math inline">\(I\)</span>.</p>
<p>Diffeomorphism: Represented as <span class="math inline">\(\leftrightsquigarrow\)</span>, these are differentiable maps with differentiable inverse. Ideally, the algorithm should output the inverse and forward mapping.</p>
<p>Composite mapping: <span class="math inline">\(\phi=\phi_1(\phi_2(x))\)</span> is defined by <span class="math inline">\(\leftrightsquigarrow \rightarrow\)</span> where <span class="math inline">\(\phi_2\)</span> is of type <span class="math inline">\(\leftrightsquigarrow\)</span>.</p>
<p>Not invertible: <span class="math inline">\(\nleftrightarrow\)</span> indicates a mapping that is not invertible.</p>
<p>Perform image warping: As an example, <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(J\)</span> represents the application of an affine transform <span class="math inline">\(\rightarrow\)</span> to image <span class="math inline">\(J\)</span> such that $J = J( A( x ) ) $.</p>
<p>Similarity measure: <span class="math inline">\(\substack{ \approx \\ s }\)</span> or <span class="math inline">\(\approx_s\)</span> indicates the metric <span class="math inline">\(s\)</span> that compares a pair of images.</p>
</div>
<div id="transforming-images" class="section level2">
<h2 class="hasAnchor">
<a href="#transforming-images" class="anchor"></a>Transforming Images</h2>
<div id="reference-space" class="section level3">
<h3 class="hasAnchor">
<a href="#reference-space" class="anchor"></a>Reference Space</h3>
<p>When applying transforms to images, it is critical to consider the information contained in the image header: spacing, origin and direction. These all play a role in the outcome. Two images with the same dimensions but different header information may have very different outcomes when transformed with the same transformation. Additionally, To transform an image, some additional information is needed in the form of a reference or target space that defines the domain of the output image. We will illustrate how this reference space works by using a simple translation transform. First, we apply the translation and use the original image space as the reference and it is clear that the image has been shifted to the left, relative to it’s original position.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">img &lt;-<span class="st"> </span><span class="kw">antsImageRead</span>(<span class="kw">getANTsRData</span>(<span class="st">"r16"</span>))
<span class="kw">invisible</span>(<span class="kw">plotColor</span>(img))</code></pre></div>
<p><img src="antsrTransform_files/figure-html/images1-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
moveX1 =<span class="st"> </span><span class="kw">createAntsrTransform</span>(<span class="dt">dimension=</span><span class="dv">2</span>, <span class="dt">type=</span><span class="st">"Euler2DTransform"</span>, <span class="dt">translation=</span><span class="kw">c</span>(<span class="dv">20</span>,<span class="dv">0</span>) )
shift1 =<span class="st"> </span><span class="kw">applyAntsrTransform</span>(<span class="dt">transform=</span>moveX1, <span class="dt">data=</span>img, <span class="dt">reference=</span>img)
<span class="kw">plotColor</span>(shift1)</code></pre></div>
<p><img src="antsrTransform_files/figure-html/images1-2.png" width="672"></p>
<p>If a large translation is applied, the image begins to leave the physical domain covered by the original input image, as shown below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">moveX2 =<span class="st"> </span><span class="kw">createAntsrTransform</span>(<span class="dt">dimension=</span><span class="dv">2</span>, <span class="dt">type=</span><span class="st">"Euler2DTransform"</span>, <span class="dt">translation=</span><span class="kw">c</span>(<span class="dv">128</span>,<span class="dv">0</span>) )
shift2 =<span class="st"> </span><span class="kw">applyAntsrTransform</span>(<span class="dt">transform=</span>moveX2, <span class="dt">data=</span>img, <span class="dt">reference=</span>img)
<span class="kw">plotColor</span>(shift2)</code></pre></div>
<p><img src="antsrTransform_files/figure-html/images2-1.png" width="672"></p>
<p>In order to see the entire brain it is necessary to define a reference space that defines the spatial domain covered by the output image. This is done with an antsImage. Now, the output image looks similar to the input image when displayed, but if the header of each image is examined it is evident that the images cover different spatial domains. It is always important consider the domains covered by images, when comparing images.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">refImg =<span class="st"> </span><span class="kw">antsImageClone</span>(img)
<span class="kw">antsSetOrigin</span>(refImg, <span class="kw">c</span>(-<span class="dv">128</span>,<span class="dv">0</span>))
<span class="co">#&gt; [1] 0</span>
shift3 =<span class="st"> </span><span class="kw">applyAntsrTransform</span>(<span class="dt">transform=</span>moveX2, <span class="dt">data=</span>img, <span class="dt">reference=</span>refImg)
<span class="kw">plotColor</span>(shift3)</code></pre></div>
<p><img src="antsrTransform_files/figure-html/images3-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(img)
<span class="co">#&gt; antsImage</span>
<span class="co">#&gt;   Pixel Type          : float </span>
<span class="co">#&gt;   Components Per Pixel: 1 </span>
<span class="co">#&gt;   Dimensions          : 256x256 </span>
<span class="co">#&gt;   Voxel Spacing       : 1x1 </span>
<span class="co">#&gt;   Origin              : 0 0 </span>
<span class="co">#&gt;   Direction           : 1 0 0 1</span>
<span class="kw">print</span>(refImg)
<span class="co">#&gt; antsImage</span>
<span class="co">#&gt;   Pixel Type          : float </span>
<span class="co">#&gt;   Components Per Pixel: 1 </span>
<span class="co">#&gt;   Dimensions          : 256x256 </span>
<span class="co">#&gt;   Voxel Spacing       : 1x1 </span>
<span class="co">#&gt;   Origin              : -128 0 </span>
<span class="co">#&gt;   Direction           : 1 0 0 1</span></code></pre></div>
</div>
<div id="interpolation" class="section level3">
<h3 class="hasAnchor">
<a href="#interpolation" class="anchor"></a>Interpolation</h3>
<p>Images represent a regular discrete sampling of a continuous physical space so it is often necessary to use interpolation to determine the value at each voxel. The default method is to use linear interpolation, and the full set available interpolators is:</p>
<ul>
<li>Linear</li>
<li>NearestNeighbor</li>
<li>BSpline</li>
<li>Gaussian</li>
<li>CosineWindowedSinc</li>
<li>HammingWindowedSinc</li>
<li>LanczosWindowedSinc</li>
<li>BlackmanWindowedSinc</li>
<li>WelchWindowedSinc</li>
<li>MultiLabel</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">img2 =<span class="st"> </span><span class="kw">applyAntsrTransform</span>(tx, <span class="dt">data=</span>img, <span class="dt">reference=</span>img)
<span class="kw">invisible</span>(<span class="kw">plotColor</span>(img2))</code></pre></div>
<p><img src="antsrTransform_files/figure-html/imagesInterp-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">img3 =<span class="st"> </span><span class="kw">applyAntsrTransform</span>(tx, <span class="dt">data=</span>img, <span class="dt">reference=</span>img, <span class="dt">interpolation=</span><span class="st">"Gaussian"</span>)
<span class="kw">invisible</span>(<span class="kw">plotColor</span>(img3))</code></pre></div>
<p><img src="antsrTransform_files/figure-html/imagesInterp-2.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">img4 =<span class="st"> </span><span class="kw">applyAntsrTransform</span>(tx, <span class="dt">data=</span>img, <span class="dt">reference=</span>img, <span class="dt">interpolation=</span><span class="st">"NearestNeighbor"</span>)
<span class="kw">invisible</span>(<span class="kw">plotColor</span>(img4))</code></pre></div>
<p><img src="antsrTransform_files/figure-html/imagesInterp-3.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">img5 =<span class="st"> </span><span class="kw">applyAntsrTransform</span>(tx, <span class="dt">data=</span>img, <span class="dt">reference=</span>img, <span class="dt">interpolation=</span><span class="st">"HammingWindowedSinc"</span>)
<span class="kw">invisible</span>(<span class="kw">plotColor</span>(img5))</code></pre></div>
<p><img src="antsrTransform_files/figure-html/imagesInterp-4.png" width="672"></p>
</div>
</div>
<div id="composing-transforms" class="section level2">
<h2 class="hasAnchor">
<a href="#composing-transforms" class="anchor"></a>Composing Transforms</h2>
<p>There is often a need to transform an image using a sequence of multiple transform. While this could be accomplished by applying each transform individually in series, this would result in a multiple interpolations, which adds error and noise to the image each time. Instead it is better to compose the series of transforms first and then apply that single final transform. The order of the transforms in the is very important. The transforms will be applied by starting at the end of the list and working to the start. This is done to remain consistent with how transform are typically represented mathematically. For example, a composite mapping written as: <span class="math inline">\(\phi=\phi_1(\phi_2(x))\)</span> means that <span class="math inline">\(\phi_2\)</span> is first applied and is followed by <span class="math inline">\(\phi_1\)</span>. The example below illustrates the importance of the order.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">txStretch =<span class="st"> </span><span class="kw">createAntsrTransform</span>( <span class="st">"AffineTransform"</span>, <span class="dt">dim=</span><span class="dv">2</span> )
params =<span class="st"> </span><span class="kw">getAntsrTransformParameters</span>( txStretch )
params[<span class="dv">1</span>] =<span class="st"> </span><span class="fl">0.8</span>
<span class="kw">setAntsrTransformParameters</span>(txStretch, params)

cos45 =<span class="st"> </span><span class="kw">cos</span>(pi*<span class="dv">45</span>/<span class="dv">180</span>)
sin45 =<span class="st"> </span><span class="kw">sin</span>(pi*<span class="dv">45</span>/<span class="dv">180</span>)
txRotate &lt;-<span class="st"> </span><span class="kw">createAntsrTransform</span>( <span class="dt">precision=</span><span class="st">"float"</span>, <span class="dt">type=</span><span class="st">"AffineTransform"</span>, <span class="dt">dim=</span><span class="dv">2</span> )
<span class="kw">setAntsrTransformParameters</span>(txRotate, <span class="kw">c</span>(cos45,-sin45,sin45,cos45,<span class="dv">0</span>,<span class="dv">0</span>) )
<span class="kw">setAntsrTransformFixedParameters</span>(txRotate, <span class="kw">c</span>(<span class="dv">128</span>,<span class="dv">128</span>))

rotateFirst =<span class="st"> </span><span class="kw">composeAntsrTransforms</span>(<span class="kw">list</span>(txStretch, txRotate))
order1 =<span class="st"> </span><span class="kw">applyAntsrTransform</span>(rotateFirst, img, img)
<span class="kw">plotColor</span>(order1)</code></pre></div>
<p><img src="antsrTransform_files/figure-html/compose-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
stretchFirst =<span class="st"> </span><span class="kw">composeAntsrTransforms</span>(<span class="kw">list</span>(txRotate, txStretch))
order2 =<span class="st"> </span><span class="kw">applyAntsrTransform</span>(stretchFirst, img, img)
<span class="kw">plotColor</span>(order2)</code></pre></div>
<p><img src="antsrTransform_files/figure-html/compose-2.png" width="672"></p>
</div>
<div id="non-linear-transforms" class="section level2">
<h2 class="hasAnchor">
<a href="#non-linear-transforms" class="anchor"></a>Non-linear transforms</h2>
<p>Non-linear transforms defined by a displacement field may also be used. Here we create an example field and apply it to the image</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
x =<span class="st"> </span>img*<span class="dv">0</span>
y =<span class="st"> </span>img*<span class="dv">0</span>
it =<span class="st"> </span><span class="kw">antsImageIterator</span>(img)
center =<span class="st"> </span><span class="kw">dim</span>(img)/<span class="dv">2</span>
while ( !<span class="kw">antsImageIteratorIsAtEnd</span>(it) )
{
  idx =<span class="st"> </span><span class="kw">antsImageIteratorGetIndex</span>(it)
  vec =<span class="st"> </span>idx -<span class="st"> </span>center
  x[idx[<span class="dv">1</span>],idx[<span class="dv">2</span>]] =<span class="st"> </span>vec[<span class="dv">1</span>]
  y[idx[<span class="dv">1</span>],idx[<span class="dv">2</span>]] =<span class="st"> </span>vec[<span class="dv">2</span>]
  it =<span class="st"> </span><span class="kw">antsImageIteratorNext</span>(it)
}

x =<span class="st"> </span>(x/<span class="kw">max</span>(x))*<span class="dv">10</span>
y =<span class="st"> </span>(y/<span class="kw">max</span>(y))*<span class="dv">4</span>
x[x&lt;<span class="dv">0</span>] =<span class="st"> </span><span class="dv">0</span>
y[y&lt;<span class="dv">0</span>] =<span class="st"> </span><span class="dv">0</span>
field =<span class="st"> </span><span class="kw">mergeChannels</span>(<span class="kw">list</span>(x,y))
subimg =<span class="st"> </span><span class="kw">as.antsImage</span>(img[<span class="dv">110</span>:<span class="dv">150</span>,<span class="dv">110</span>:<span class="dv">150</span>])
subx =<span class="st"> </span><span class="kw">as.antsImage</span>(x[<span class="dv">110</span>:<span class="dv">150</span>,<span class="dv">110</span>:<span class="dv">150</span>])
suby =<span class="st"> </span><span class="kw">as.antsImage</span>(y[<span class="dv">110</span>:<span class="dv">150</span>,<span class="dv">110</span>:<span class="dv">150</span>])
<span class="kw">invisible</span>(<span class="kw">plotColor</span>(subimg, <span class="dt">vectors=</span><span class="kw">list</span>(subx,-suby)))</code></pre></div>
<p><img src="antsrTransform_files/figure-html/warp-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
warpTx =<span class="st"> </span><span class="kw">antsrTransformFromDisplacementField</span>( field )
warped =<span class="st"> </span><span class="kw">applyAntsrTransform</span>(warpTx,<span class="dt">data=</span>img,<span class="dt">reference=</span>img)
<span class="kw">invisible</span>(<span class="kw">plotColor</span>(warped))</code></pre></div>
<p><img src="antsrTransform_files/figure-html/warp-2.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">invisible</span>(<span class="kw">plotColor</span>(<span class="kw">abs</span>(img-warped)))</code></pre></div>
<p><img src="antsrTransform_files/figure-html/warp-3.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
warped2 =<span class="st"> </span><span class="kw">applyAntsrTransform</span>(<span class="dt">transform=</span><span class="kw">list</span>(warpTx,tx), <span class="dt">data=</span>img, <span class="dt">reference=</span>img)
<span class="kw">invisible</span>(<span class="kw">plotColor</span>(warped2))</code></pre></div>
<p><img src="antsrTransform_files/figure-html/warp-4.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">invisible</span>(<span class="kw">plotColor</span>(<span class="kw">abs</span>(warped2-img2)))</code></pre></div>
<p><img src="antsrTransform_files/figure-html/warp-5.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
warped3 =<span class="st"> </span><span class="kw">applyAntsrTransform</span>(<span class="dt">transform=</span><span class="kw">list</span>(tx,warpTx), <span class="dt">data=</span>img, <span class="dt">reference=</span>img)
<span class="kw">invisible</span>(<span class="kw">plotColor</span>(warped3))</code></pre></div>
<p><img src="antsrTransform_files/figure-html/warp-6.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">invisible</span>(<span class="kw">plotColor</span>(<span class="kw">abs</span>(warped3-img2)))</code></pre></div>
<p><img src="antsrTransform_files/figure-html/warp-7.png" width="672"></p>
</div>
<div id="file-io" class="section level2">
<h2 class="hasAnchor">
<a href="#file-io" class="anchor"></a>File IO</h2>
<p>Routines are provided to read transforms from file, for both linear and non-linear. Methods for writing transforms to file are under development. It is important to note that when converting from a multichannel antsImage to a <code>DisplacementField</code> transform, the data is copied so later changes to the antsImage, will not propagate to the transform, the transform would need to be reinitialized with the modified antsImage. This is due to underlying differences in data representation.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Don't run until we have test files</span>
<span class="co">#linTx = readAntsrTransform("yourfile.mat")</span>
<span class="co">#warpImage = antsImageRead("yourfield.nii.gz")</span>
<span class="co">#warpTx = antsrTransformFromDisplacementField(warpImage)</span></code></pre></div>
</div>
<div id="available-linear-transforms" class="section level2">
<h2 class="hasAnchor">
<a href="#available-linear-transforms" class="anchor"></a>Available Linear Transforms</h2>
<p>Descriptions of the transform types comes from the ITK documentation of the associated class.</p>
<p>Many of these transforms have a center and offset that can be set. Here are some words of caution from the ITK documentation.</p>
<p>The center of rotation of an antsrTransform is a fixed point - for most transforms here, this point is not a “parameter” of the transform - the exception is that “centered” transforms have center as a parameter during optimization.</p>
<p>WARNING: When using the Center, we strongly recommend only changing the matrix and translation to define a transform. Changing a transform’s center, changes the mapping between spaces - specifically, translation is not changed with respect to that new center, and so the offset is updated to * maintain the consistency with translation. If a center is not used, or is set before the matrix and the offset, then it is safe to change the offset directly.</p>
<p>As a rule of thumb, if you wish to set the center explicitly, set before Offset computations are done.</p>
<p>To define an affine transform, you must set the matrix, center, and translation OR the matrix and offset</p>
<div id="affinetransform---itk" class="section level3">
<h3 class="hasAnchor">
<a href="#affinetransform---itk" class="anchor"></a>AffineTransform - <a href="http://www.itk.org/Doxygen/html/classitk_1_1AffineTransform.html">ITK</a>
</h3>
<p>An affine transformation is defined mathematically as a linear transformation plus a constant offset. If A is a constant n x n matrix and b is a constant n-vector, then y = Ax+b defines an affine transformation from the n-vector x to the n-vector y. Any two affine transformations may be composed and the result is another affine transformation. However, the order is important. This class also supports the specification of a center of rotation (center) and a translation that is applied with respect to that centered rotation. By default the center of rotation is set to the origin.</p>
<p><em>Parameters</em>: The first (NDimension x NDimension) parameters defines the matrix in row-major order (where the column index varies the fastest). The last NDimension parameters defines the translation in each dimensions.</p>
<p><em>FixedParameters</em>: The NDimension coordinates of the center of rotation</p>
</div>
<div id="centeredaffinetransform---itk" class="section level3">
<h3 class="hasAnchor">
<a href="#centeredaffinetransform---itk" class="anchor"></a>CenteredAffineTransform - <a href="http://www.itk.org/Doxygen/html/classitk_1_1CenteredAffineTransform.html">ITK</a>
</h3>
<p>Affine transformation with a specified center of rotation.</p>
<p><em>Parameters</em>: The first (NDimension x NDimension) parameters define the matrix, the next N parameters define the center of rotation and the last N parameters define the translation to be applied after the coordinate system has been restored to the rotation center. Note that the Offset of the superclass is no longer in the parameters array since it is fully dependent on the rotation center and the translation parameters.</p>
<p><em>FixedParameters</em>: None</p>
</div>
<div id="centeredeuler3dtransform---itk" class="section level3">
<h3 class="hasAnchor">
<a href="#centeredeuler3dtransform---itk" class="anchor"></a>CenteredEuler3DTransform - <a href="http://www.itk.org/Doxygen/html/classitk_1_1CenteredEuler3DTransform.html">ITK</a>
</h3>
<p>This transform applies a rotation about a specific coordinate or centre of rotation followed by a translation.</p>
<p><em>Parameters</em>: An array with 9 values, ordered as follows:</p>
<ul>
<li>p[1] = angle around x-axis (in radians)</li>
<li>p[2] = angle around y-axis (in radians)</li>
<li>p[3] = angle around z-axis (in radians)</li>
<li>p[4] = x coordinate of center</li>
<li>p[5] = y coordinate of center</li>
<li>p[6] = z coordinate of center</li>
<li>p[7] = x component of translation</li>
<li>p[8] = y component of translation</li>
<li>p[9] = z component of translation</li>
</ul>
<p><em>FixedParameters</em>: None</p>
</div>
<div id="centeredrigid2dtransform---itk" class="section level3">
<h3 class="hasAnchor">
<a href="#centeredrigid2dtransform---itk" class="anchor"></a>CenteredRigid2DTransform - <a href="http://www.itk.org/Doxygen/html/classitk_1_1CenteredRigid2DTransform.html">ITK</a>
</h3>
<p>This transform applies a rigid transformation is 2D space. The transform is specified as a rotation around arbitrary center and is followed by a translation. The main difference between this class and its superclass Rigid2DTransform is that the center of rotation is exposed for optimization.</p>
<p><em>Parameters</em>: An array of 5 elements ordered as follows:</p>
<ul>
<li>p[1] = angle (in radians)</li>
<li>p[2] = x coordinate of center</li>
<li>p[3] = y coordinate of center</li>
<li>p[4] = x component of translation</li>
<li>p[5] = y component of translation</li>
</ul>
<p><em>FixedParameters</em>: None</p>
</div>
<div id="centeredsimilarity2dtransform---itk" class="section level3">
<h3 class="hasAnchor">
<a href="#centeredsimilarity2dtransform---itk" class="anchor"></a>CenteredSimilarity2DTransform - <a href="http://www.itk.org/Doxygen/html/classitk_1_1CenteredSimilarity2DTransform.html">ITK</a>
</h3>
<p>This transform applies a homogenous scale and rigid transform in 2D space. The transform is specified as a scale and rotation around a arbitrary center and is followed by a translation. given one angle for rotation, a homogeneous scale and a 2D offset for translation.</p>
<p>The main difference between this class and its superclass Similarity2DTransform is that the center of transformation is exposed for optimization.</p>
<p><em>Parameters</em>: an array of 6 elements ordered as follows:</p>
<ul>
<li>p[1] = scale</li>
<li>p[2] = angle (in radians)</li>
<li>p[3] = x coordinate of the center</li>
<li>p[4] = y coordinate of the center</li>
<li>p[5] = x component of the translation</li>
<li>p[6] = y component of the translation</li>
</ul>
<p><em>FixedParameters</em>: None</p>
</div>
<div id="euler2dtransform---itk" class="section level3">
<h3 class="hasAnchor">
<a href="#euler2dtransform---itk" class="anchor"></a>Euler2DTransform - <a href="http://www.itk.org/Doxygen/html/classitk_1_1Euler2DTransform.html">ITK</a>
</h3>
<p>This transform applies a rigid transformation is 2D space. The transform is specified as a rotation around arbitrary center and is followed by a translation. This transform is basically is a synonym for Rigid2DTransform.</p>
<p><em>Parameters</em>: An array of 3 elements ordered as follows:</p>
<ul>
<li>p[1] = angle (in radians)</li>
<li>p[2] = x component of translation</li>
<li>p[3] = y component of translation</li>
</ul>
<p><em>FixedParameters</em>: center of rotation</p>
<ul>
<li>p[1] = x coordinate of center</li>
<li>p[2] = y coordinate of center</li>
</ul>
</div>
<div id="euler3dtransform---itk" class="section level3">
<h3 class="hasAnchor">
<a href="#euler3dtransform---itk" class="anchor"></a>Euler3DTransform - <a href="http://www.itk.org/Doxygen/html/classitk_1_1Euler3DTransform.html">ITK</a>
</h3>
<p>This transform applies a rotation and translation to the space given 3 Euler angles and a 3D translation. Rotation is about a user specified center.</p>
<p><em>Parameters</em>: An array of 6 elements, ordered as follows:</p>
<ul>
<li>p[1] = angle around x-axis (in radians)</li>
<li>p[2] = angle around y-axis (in radians)</li>
<li>p[3] = angle around z-axis (in radians)</li>
<li>p[4] = x component of translation</li>
<li>p[5] = y component of translation</li>
<li>p[6] = z component of translation</li>
</ul>
<p><em>FixedParameters</em>: An array of 3 element, defining the center of rotation</p>
<ul>
<li>p[1] = x coordinate of center</li>
<li>p[2] = y coordinate of center</li>
<li>p[3] = z coordinate of center</li>
</ul>
</div>
<div id="quaternionrigidtransform---itk" class="section level3">
<h3 class="hasAnchor">
<a href="#quaternionrigidtransform---itk" class="anchor"></a>QuaternionRigidTransform - <a href="http://www.itk.org/Doxygen/html/classitk_1_1QuaternionRigidTransform.html">ITK</a>
</h3>
<p>This transform applies a rotation and translation to the space given a quaternion and a 3D translation. Rotation is about a user specified center.</p>
<p><em>Parameters</em>: An array of 7 elements.</p>
<ul>
<li>p[1] = x components of rotation axis</li>
<li>p[2] = y components of rotation axis</li>
<li>p[3] = z components of rotation axis</li>
<li>p[4] = angle around rotation axis (in radians)</li>
<li>p[5] = x component of translation</li>
<li>p[6] = y component of translation</li>
<li>p[7] = z component of translation</li>
</ul>
<p><em>FixedParameters</em>: An array of 3 elements defining the center of rotation</p>
<ul>
<li>p[1] = x coordinate of center</li>
<li>p[2] = y coordinate of center</li>
<li>p[3] = z coordinate of center</li>
</ul>
</div>
<div id="rigid2dtransform---itk" class="section level3">
<h3 class="hasAnchor">
<a href="#rigid2dtransform---itk" class="anchor"></a>Rigid2DTransform - <a href="http://www.itk.org/Doxygen/html/classitk_1_1Rigid2DTransform.html">ITK</a>
</h3>
<p>This transform applies a rigid transformation is 2D space. The transform is specified as a rotation around arbitrary center and is followed by a translation.</p>
<p><em>Parameters</em>: An array of 3 elements ordered as follows:</p>
<ul>
<li>p[1] = angle (in radians)</li>
<li>p[2] = x component of translation</li>
<li>p[3] = y component of translation</li>
</ul>
<p><em>FixedParameters</em>: center of rotation</p>
<ul>
<li>p[1] = x coordinate of center</li>
<li>p[2] = y coordinate of center</li>
</ul>
</div>
<div id="similarity2dtransform---itk" class="section level3">
<h3 class="hasAnchor">
<a href="#similarity2dtransform---itk" class="anchor"></a>Similarity2DTransform - <a href="http://www.itk.org/Doxygen/html/classitk_1_1Similarity2DTransform.html">ITK</a>
</h3>
<p>This transform applies a homogenous scale and rigid transform in 2D space. The transform is specified as a scale and rotation around a arbitrary center and is followed by a translation. Given one angle for rotation, a homogeneous scale and a 2D offset for translation.</p>
<p><em>Parameters</em>: scale, angle and translation, ordered as follows:</p>
<ul>
<li>p[1] = scale</li>
<li>p[2] = angle (in radians)</li>
<li>p[3] = x component of translation</li>
<li>p[4] = y component of translation</li>
</ul>
<p><em>FixedParameters</em>: center of rotation</p>
<ul>
<li>p[1] = x coordinate of center</li>
<li>p[2] = y coordinate of center</li>
</ul>
</div>
<div id="similarity3dtransform" class="section level3">
<h3 class="hasAnchor">
<a href="#similarity3dtransform" class="anchor"></a>Similarity3DTransform</h3>
<p>This transform applies a rotation, translation and isotropic scaling to the space.</p>
<p><em>Parameters</em>: An array of 7 elements</p>
<ul>
<li>p[1] = angle around x-axis (in radians)</li>
<li>p[2] = angle around y-axis (in radians)</li>
<li>p[3] = angle around z-axis (in radians)</li>
<li>p[4] = x coordinate of center</li>
<li>p[5] = y coordinate of center</li>
<li>p[6] = z coordinate of center</li>
<li>p[7] = scale</li>
</ul>
<p><em>FixedParameters</em>: center of rotation</p>
<ul>
<li>p[1] = x coordinate of center</li>
<li>p[2] = y coordinate of center</li>
<li>p[3] = z coordinate of center</li>
</ul>
</div>
</div>
<div id="references" class="section level2">
<h2 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h2>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#overview">Overview</a></li>
      <li><a href="#transforming-point-and-vector-data">Transforming point and vector data</a></li>
      <li><a href="#nomenclature-talking-about-talking-about-transforms">Nomenclature: talking about talking about transforms</a></li>
      <li><a href="#transforming-images">Transforming Images</a></li>
      <li><a href="#composing-transforms">Composing Transforms</a></li>
      <li><a href="#non-linear-transforms">Non-linear transforms</a></li>
      <li><a href="#file-io">File IO</a></li>
      <li><a href="#available-linear-transforms">Available Linear Transforms</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Brian B Avants.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
